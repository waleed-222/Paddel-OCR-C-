// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: paddle/phi/core/framework/framework.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_paddle_2fphi_2fcore_2fframework_2fframework_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_paddle_2fphi_2fcore_2fframework_2fframework_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_paddle_2fphi_2fcore_2fframework_2fframework_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_paddle_2fphi_2fcore_2fframework_2fframework_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_paddle_2fphi_2fcore_2fframework_2fframework_2eproto;
namespace paddle {
namespace framework {
namespace proto {
class BlockDesc;
struct BlockDescDefaultTypeInternal;
extern BlockDescDefaultTypeInternal _BlockDesc_default_instance_;
class Complex;
struct ComplexDefaultTypeInternal;
extern ComplexDefaultTypeInternal _Complex_default_instance_;
class OpDesc;
struct OpDescDefaultTypeInternal;
extern OpDescDefaultTypeInternal _OpDesc_default_instance_;
class OpDesc_Attr;
struct OpDesc_AttrDefaultTypeInternal;
extern OpDesc_AttrDefaultTypeInternal _OpDesc_Attr_default_instance_;
class OpDesc_Var;
struct OpDesc_VarDefaultTypeInternal;
extern OpDesc_VarDefaultTypeInternal _OpDesc_Var_default_instance_;
class OpProto;
struct OpProtoDefaultTypeInternal;
extern OpProtoDefaultTypeInternal _OpProto_default_instance_;
class OpProto_Attr;
struct OpProto_AttrDefaultTypeInternal;
extern OpProto_AttrDefaultTypeInternal _OpProto_Attr_default_instance_;
class OpProto_Var;
struct OpProto_VarDefaultTypeInternal;
extern OpProto_VarDefaultTypeInternal _OpProto_Var_default_instance_;
class OpVersion;
struct OpVersionDefaultTypeInternal;
extern OpVersionDefaultTypeInternal _OpVersion_default_instance_;
class OpVersionMap;
struct OpVersionMapDefaultTypeInternal;
extern OpVersionMapDefaultTypeInternal _OpVersionMap_default_instance_;
class OpVersionMap_OpVersionPair;
struct OpVersionMap_OpVersionPairDefaultTypeInternal;
extern OpVersionMap_OpVersionPairDefaultTypeInternal _OpVersionMap_OpVersionPair_default_instance_;
class ProgramDesc;
struct ProgramDescDefaultTypeInternal;
extern ProgramDescDefaultTypeInternal _ProgramDesc_default_instance_;
class Scalar;
struct ScalarDefaultTypeInternal;
extern ScalarDefaultTypeInternal _Scalar_default_instance_;
class VarDesc;
struct VarDescDefaultTypeInternal;
extern VarDescDefaultTypeInternal _VarDesc_default_instance_;
class VarDesc_Attr;
struct VarDesc_AttrDefaultTypeInternal;
extern VarDesc_AttrDefaultTypeInternal _VarDesc_Attr_default_instance_;
class VarType;
struct VarTypeDefaultTypeInternal;
extern VarTypeDefaultTypeInternal _VarType_default_instance_;
class VarType_DenseTensorArrayDesc;
struct VarType_DenseTensorArrayDescDefaultTypeInternal;
extern VarType_DenseTensorArrayDescDefaultTypeInternal _VarType_DenseTensorArrayDesc_default_instance_;
class VarType_DenseTensorDesc;
struct VarType_DenseTensorDescDefaultTypeInternal;
extern VarType_DenseTensorDescDefaultTypeInternal _VarType_DenseTensorDesc_default_instance_;
class VarType_ReaderDesc;
struct VarType_ReaderDescDefaultTypeInternal;
extern VarType_ReaderDescDefaultTypeInternal _VarType_ReaderDesc_default_instance_;
class VarType_TensorDesc;
struct VarType_TensorDescDefaultTypeInternal;
extern VarType_TensorDescDefaultTypeInternal _VarType_TensorDesc_default_instance_;
class VarType_Tuple;
struct VarType_TupleDefaultTypeInternal;
extern VarType_TupleDefaultTypeInternal _VarType_Tuple_default_instance_;
class Version;
struct VersionDefaultTypeInternal;
extern VersionDefaultTypeInternal _Version_default_instance_;
}  // namespace proto
}  // namespace framework
}  // namespace paddle
PROTOBUF_NAMESPACE_OPEN
template<> ::paddle::framework::proto::BlockDesc* Arena::CreateMaybeMessage<::paddle::framework::proto::BlockDesc>(Arena*);
template<> ::paddle::framework::proto::Complex* Arena::CreateMaybeMessage<::paddle::framework::proto::Complex>(Arena*);
template<> ::paddle::framework::proto::OpDesc* Arena::CreateMaybeMessage<::paddle::framework::proto::OpDesc>(Arena*);
template<> ::paddle::framework::proto::OpDesc_Attr* Arena::CreateMaybeMessage<::paddle::framework::proto::OpDesc_Attr>(Arena*);
template<> ::paddle::framework::proto::OpDesc_Var* Arena::CreateMaybeMessage<::paddle::framework::proto::OpDesc_Var>(Arena*);
template<> ::paddle::framework::proto::OpProto* Arena::CreateMaybeMessage<::paddle::framework::proto::OpProto>(Arena*);
template<> ::paddle::framework::proto::OpProto_Attr* Arena::CreateMaybeMessage<::paddle::framework::proto::OpProto_Attr>(Arena*);
template<> ::paddle::framework::proto::OpProto_Var* Arena::CreateMaybeMessage<::paddle::framework::proto::OpProto_Var>(Arena*);
template<> ::paddle::framework::proto::OpVersion* Arena::CreateMaybeMessage<::paddle::framework::proto::OpVersion>(Arena*);
template<> ::paddle::framework::proto::OpVersionMap* Arena::CreateMaybeMessage<::paddle::framework::proto::OpVersionMap>(Arena*);
template<> ::paddle::framework::proto::OpVersionMap_OpVersionPair* Arena::CreateMaybeMessage<::paddle::framework::proto::OpVersionMap_OpVersionPair>(Arena*);
template<> ::paddle::framework::proto::ProgramDesc* Arena::CreateMaybeMessage<::paddle::framework::proto::ProgramDesc>(Arena*);
template<> ::paddle::framework::proto::Scalar* Arena::CreateMaybeMessage<::paddle::framework::proto::Scalar>(Arena*);
template<> ::paddle::framework::proto::VarDesc* Arena::CreateMaybeMessage<::paddle::framework::proto::VarDesc>(Arena*);
template<> ::paddle::framework::proto::VarDesc_Attr* Arena::CreateMaybeMessage<::paddle::framework::proto::VarDesc_Attr>(Arena*);
template<> ::paddle::framework::proto::VarType* Arena::CreateMaybeMessage<::paddle::framework::proto::VarType>(Arena*);
template<> ::paddle::framework::proto::VarType_DenseTensorArrayDesc* Arena::CreateMaybeMessage<::paddle::framework::proto::VarType_DenseTensorArrayDesc>(Arena*);
template<> ::paddle::framework::proto::VarType_DenseTensorDesc* Arena::CreateMaybeMessage<::paddle::framework::proto::VarType_DenseTensorDesc>(Arena*);
template<> ::paddle::framework::proto::VarType_ReaderDesc* Arena::CreateMaybeMessage<::paddle::framework::proto::VarType_ReaderDesc>(Arena*);
template<> ::paddle::framework::proto::VarType_TensorDesc* Arena::CreateMaybeMessage<::paddle::framework::proto::VarType_TensorDesc>(Arena*);
template<> ::paddle::framework::proto::VarType_Tuple* Arena::CreateMaybeMessage<::paddle::framework::proto::VarType_Tuple>(Arena*);
template<> ::paddle::framework::proto::Version* Arena::CreateMaybeMessage<::paddle::framework::proto::Version>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace paddle {
namespace framework {
namespace proto {

enum Scalar_Type : int {
  Scalar_Type_BOOLEAN = 1,
  Scalar_Type_LONG = 2,
  Scalar_Type_FLOAT64 = 3,
  Scalar_Type_COMPLEX128 = 4
};
bool Scalar_Type_IsValid(int value);
constexpr Scalar_Type Scalar_Type_Type_MIN = Scalar_Type_BOOLEAN;
constexpr Scalar_Type Scalar_Type_Type_MAX = Scalar_Type_COMPLEX128;
constexpr int Scalar_Type_Type_ARRAYSIZE = Scalar_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Scalar_Type_descriptor();
template<typename T>
inline const std::string& Scalar_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Scalar_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Scalar_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Scalar_Type_descriptor(), enum_t_value);
}
inline bool Scalar_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Scalar_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Scalar_Type>(
    Scalar_Type_descriptor(), name, value);
}
enum VarType_Type : int {
  VarType_Type_BOOL = 0,
  VarType_Type_INT16 = 1,
  VarType_Type_INT32 = 2,
  VarType_Type_INT64 = 3,
  VarType_Type_FP16 = 4,
  VarType_Type_FP32 = 5,
  VarType_Type_FP64 = 6,
  VarType_Type_SIZE_T = 19,
  VarType_Type_UINT8 = 20,
  VarType_Type_INT8 = 21,
  VarType_Type_BF16 = 22,
  VarType_Type_COMPLEX64 = 23,
  VarType_Type_COMPLEX128 = 24,
  VarType_Type_FP8_E4M3FN = 32,
  VarType_Type_FP8_E5M2 = 33,
  VarType_Type_DENSE_TENSOR = 7,
  VarType_Type_SELECTED_ROWS = 8,
  VarType_Type_FEED_MINIBATCH = 9,
  VarType_Type_FETCH_LIST = 10,
  VarType_Type_STEP_SCOPES = 11,
  VarType_Type_LOD_RANK_TABLE = 12,
  VarType_Type_DENSE_TENSOR_ARRAY = 13,
  VarType_Type_PLACE_LIST = 14,
  VarType_Type_READER = 15,
  VarType_Type_RAW = 17,
  VarType_Type_TUPLE = 18,
  VarType_Type_STRING = 25,
  VarType_Type_STRINGS = 26,
  VarType_Type_VOCAB = 27,
  VarType_Type_FEED_LIST = 28,
  VarType_Type_PSTRING = 29,
  VarType_Type_SPARSE_COO = 30,
  VarType_Type_SPARSE_CSR = 31
};
bool VarType_Type_IsValid(int value);
constexpr VarType_Type VarType_Type_Type_MIN = VarType_Type_BOOL;
constexpr VarType_Type VarType_Type_Type_MAX = VarType_Type_FP8_E5M2;
constexpr int VarType_Type_Type_ARRAYSIZE = VarType_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VarType_Type_descriptor();
template<typename T>
inline const std::string& VarType_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VarType_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VarType_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VarType_Type_descriptor(), enum_t_value);
}
inline bool VarType_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VarType_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VarType_Type>(
    VarType_Type_descriptor(), name, value);
}
enum AttrType : int {
  INT = 0,
  FLOAT = 1,
  STRING = 2,
  INTS = 3,
  FLOATS = 4,
  STRINGS = 5,
  BOOLEAN = 6,
  BOOLEANS = 7,
  BLOCK = 8,
  LONG = 9,
  BLOCKS = 10,
  LONGS = 11,
  FLOAT64S = 12,
  VAR = 13,
  VARS = 14,
  FLOAT64 = 15,
  SCALAR = 16,
  SCALARS = 17
};
bool AttrType_IsValid(int value);
constexpr AttrType AttrType_MIN = INT;
constexpr AttrType AttrType_MAX = SCALARS;
constexpr int AttrType_ARRAYSIZE = AttrType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AttrType_descriptor();
template<typename T>
inline const std::string& AttrType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AttrType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AttrType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AttrType_descriptor(), enum_t_value);
}
inline bool AttrType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AttrType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AttrType>(
    AttrType_descriptor(), name, value);
}
// ===================================================================

class Version final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:paddle.framework.proto.Version) */ {
 public:
  inline Version() : Version(nullptr) {}
  ~Version() override;
  explicit PROTOBUF_CONSTEXPR Version(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Version(const Version& from);
  Version(Version&& from) noexcept
    : Version() {
    *this = ::std::move(from);
  }

  inline Version& operator=(const Version& from) {
    CopyFrom(from);
    return *this;
  }
  inline Version& operator=(Version&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Version& default_instance() {
    return *internal_default_instance();
  }
  static inline const Version* internal_default_instance() {
    return reinterpret_cast<const Version*>(
               &_Version_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Version& a, Version& b) {
    a.Swap(&b);
  }
  inline void Swap(Version* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Version* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Version* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Version>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Version& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Version& from) {
    Version::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Version* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "paddle.framework.proto.Version";
  }
  protected:
  explicit Version(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
  };
  // optional int64 version = 1 [default = 0];
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  int64_t version() const;
  void set_version(int64_t value);
  private:
  int64_t _internal_version() const;
  void _internal_set_version(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:paddle.framework.proto.Version)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t version_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_paddle_2fphi_2fcore_2fframework_2fframework_2eproto;
};
// -------------------------------------------------------------------

class Complex final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:paddle.framework.proto.Complex) */ {
 public:
  inline Complex() : Complex(nullptr) {}
  ~Complex() override;
  explicit PROTOBUF_CONSTEXPR Complex(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Complex(const Complex& from);
  Complex(Complex&& from) noexcept
    : Complex() {
    *this = ::std::move(from);
  }

  inline Complex& operator=(const Complex& from) {
    CopyFrom(from);
    return *this;
  }
  inline Complex& operator=(Complex&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Complex& default_instance() {
    return *internal_default_instance();
  }
  static inline const Complex* internal_default_instance() {
    return reinterpret_cast<const Complex*>(
               &_Complex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Complex& a, Complex& b) {
    a.Swap(&b);
  }
  inline void Swap(Complex* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Complex* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Complex* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Complex>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Complex& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Complex& from) {
    Complex::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Complex* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "paddle.framework.proto.Complex";
  }
  protected:
  explicit Complex(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRFieldNumber = 1,
    kIFieldNumber = 2,
  };
  // required double r = 1;
  bool has_r() const;
  private:
  bool _internal_has_r() const;
  public:
  void clear_r();
  double r() const;
  void set_r(double value);
  private:
  double _internal_r() const;
  void _internal_set_r(double value);
  public:

  // required double i = 2;
  bool has_i() const;
  private:
  bool _internal_has_i() const;
  public:
  void clear_i();
  double i() const;
  void set_i(double value);
  private:
  double _internal_i() const;
  void _internal_set_i(double value);
  public:

  // @@protoc_insertion_point(class_scope:paddle.framework.proto.Complex)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double r_;
    double i_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_paddle_2fphi_2fcore_2fframework_2fframework_2eproto;
};
// -------------------------------------------------------------------

class Scalar final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:paddle.framework.proto.Scalar) */ {
 public:
  inline Scalar() : Scalar(nullptr) {}
  ~Scalar() override;
  explicit PROTOBUF_CONSTEXPR Scalar(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Scalar(const Scalar& from);
  Scalar(Scalar&& from) noexcept
    : Scalar() {
    *this = ::std::move(from);
  }

  inline Scalar& operator=(const Scalar& from) {
    CopyFrom(from);
    return *this;
  }
  inline Scalar& operator=(Scalar&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Scalar& default_instance() {
    return *internal_default_instance();
  }
  static inline const Scalar* internal_default_instance() {
    return reinterpret_cast<const Scalar*>(
               &_Scalar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Scalar& a, Scalar& b) {
    a.Swap(&b);
  }
  inline void Swap(Scalar* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Scalar* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Scalar* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Scalar>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Scalar& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Scalar& from) {
    Scalar::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Scalar* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "paddle.framework.proto.Scalar";
  }
  protected:
  explicit Scalar(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Scalar_Type Type;
  static constexpr Type BOOLEAN =
    Scalar_Type_BOOLEAN;
  static constexpr Type LONG =
    Scalar_Type_LONG;
  static constexpr Type FLOAT64 =
    Scalar_Type_FLOAT64;
  static constexpr Type COMPLEX128 =
    Scalar_Type_COMPLEX128;
  static inline bool Type_IsValid(int value) {
    return Scalar_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Scalar_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Scalar_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Scalar_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return Scalar_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Scalar_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return Scalar_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCFieldNumber = 5,
    kIFieldNumber = 3,
    kRFieldNumber = 4,
    kBFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // optional .paddle.framework.proto.Complex c = 5;
  bool has_c() const;
  private:
  bool _internal_has_c() const;
  public:
  void clear_c();
  const ::paddle::framework::proto::Complex& c() const;
  PROTOBUF_NODISCARD ::paddle::framework::proto::Complex* release_c();
  ::paddle::framework::proto::Complex* mutable_c();
  void set_allocated_c(::paddle::framework::proto::Complex* c);
  private:
  const ::paddle::framework::proto::Complex& _internal_c() const;
  ::paddle::framework::proto::Complex* _internal_mutable_c();
  public:
  void unsafe_arena_set_allocated_c(
      ::paddle::framework::proto::Complex* c);
  ::paddle::framework::proto::Complex* unsafe_arena_release_c();

  // optional int64 i = 3;
  bool has_i() const;
  private:
  bool _internal_has_i() const;
  public:
  void clear_i();
  int64_t i() const;
  void set_i(int64_t value);
  private:
  int64_t _internal_i() const;
  void _internal_set_i(int64_t value);
  public:

  // optional double r = 4;
  bool has_r() const;
  private:
  bool _internal_has_r() const;
  public:
  void clear_r();
  double r() const;
  void set_r(double value);
  private:
  double _internal_r() const;
  void _internal_set_r(double value);
  public:

  // optional bool b = 2;
  bool has_b() const;
  private:
  bool _internal_has_b() const;
  public:
  void clear_b();
  bool b() const;
  void set_b(bool value);
  private:
  bool _internal_b() const;
  void _internal_set_b(bool value);
  public:

  // required .paddle.framework.proto.Scalar.Type type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::paddle::framework::proto::Scalar_Type type() const;
  void set_type(::paddle::framework::proto::Scalar_Type value);
  private:
  ::paddle::framework::proto::Scalar_Type _internal_type() const;
  void _internal_set_type(::paddle::framework::proto::Scalar_Type value);
  public:

  // @@protoc_insertion_point(class_scope:paddle.framework.proto.Scalar)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::paddle::framework::proto::Complex* c_;
    int64_t i_;
    double r_;
    bool b_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_paddle_2fphi_2fcore_2fframework_2fframework_2eproto;
};
// -------------------------------------------------------------------

class OpDesc_Attr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:paddle.framework.proto.OpDesc.Attr) */ {
 public:
  inline OpDesc_Attr() : OpDesc_Attr(nullptr) {}
  ~OpDesc_Attr() override;
  explicit PROTOBUF_CONSTEXPR OpDesc_Attr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpDesc_Attr(const OpDesc_Attr& from);
  OpDesc_Attr(OpDesc_Attr&& from) noexcept
    : OpDesc_Attr() {
    *this = ::std::move(from);
  }

  inline OpDesc_Attr& operator=(const OpDesc_Attr& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpDesc_Attr& operator=(OpDesc_Attr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpDesc_Attr& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpDesc_Attr* internal_default_instance() {
    return reinterpret_cast<const OpDesc_Attr*>(
               &_OpDesc_Attr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(OpDesc_Attr& a, OpDesc_Attr& b) {
    a.Swap(&b);
  }
  inline void Swap(OpDesc_Attr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpDesc_Attr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpDesc_Attr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpDesc_Attr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpDesc_Attr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpDesc_Attr& from) {
    OpDesc_Attr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpDesc_Attr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "paddle.framework.proto.OpDesc.Attr";
  }
  protected:
  explicit OpDesc_Attr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntsFieldNumber = 6,
    kFloatsFieldNumber = 7,
    kStringsFieldNumber = 8,
    kBoolsFieldNumber = 11,
    kBlocksIdxFieldNumber = 14,
    kLongsFieldNumber = 15,
    kFloat64SFieldNumber = 16,
    kVarsNameFieldNumber = 18,
    kScalarsFieldNumber = 21,
    kNameFieldNumber = 1,
    kSFieldNumber = 5,
    kVarNameFieldNumber = 17,
    kScalarFieldNumber = 20,
    kTypeFieldNumber = 2,
    kIFieldNumber = 3,
    kFFieldNumber = 4,
    kBFieldNumber = 10,
    kLFieldNumber = 13,
    kFloat64FieldNumber = 19,
    kBlockIdxFieldNumber = 12,
  };
  // repeated int32 ints = 6;
  int ints_size() const;
  private:
  int _internal_ints_size() const;
  public:
  void clear_ints();
  private:
  int32_t _internal_ints(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_ints() const;
  void _internal_add_ints(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_ints();
  public:
  int32_t ints(int index) const;
  void set_ints(int index, int32_t value);
  void add_ints(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      ints() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_ints();

  // repeated float floats = 7;
  int floats_size() const;
  private:
  int _internal_floats_size() const;
  public:
  void clear_floats();
  private:
  float _internal_floats(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_floats() const;
  void _internal_add_floats(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_floats();
  public:
  float floats(int index) const;
  void set_floats(int index, float value);
  void add_floats(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      floats() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_floats();

  // repeated string strings = 8;
  int strings_size() const;
  private:
  int _internal_strings_size() const;
  public:
  void clear_strings();
  const std::string& strings(int index) const;
  std::string* mutable_strings(int index);
  void set_strings(int index, const std::string& value);
  void set_strings(int index, std::string&& value);
  void set_strings(int index, const char* value);
  void set_strings(int index, const char* value, size_t size);
  std::string* add_strings();
  void add_strings(const std::string& value);
  void add_strings(std::string&& value);
  void add_strings(const char* value);
  void add_strings(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& strings() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_strings();
  private:
  const std::string& _internal_strings(int index) const;
  std::string* _internal_add_strings();
  public:

  // repeated bool bools = 11;
  int bools_size() const;
  private:
  int _internal_bools_size() const;
  public:
  void clear_bools();
  private:
  bool _internal_bools(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_bools() const;
  void _internal_add_bools(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_bools();
  public:
  bool bools(int index) const;
  void set_bools(int index, bool value);
  void add_bools(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      bools() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_bools();

  // repeated int32 blocks_idx = 14;
  int blocks_idx_size() const;
  private:
  int _internal_blocks_idx_size() const;
  public:
  void clear_blocks_idx();
  private:
  int32_t _internal_blocks_idx(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_blocks_idx() const;
  void _internal_add_blocks_idx(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_blocks_idx();
  public:
  int32_t blocks_idx(int index) const;
  void set_blocks_idx(int index, int32_t value);
  void add_blocks_idx(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      blocks_idx() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_blocks_idx();

  // repeated int64 longs = 15;
  int longs_size() const;
  private:
  int _internal_longs_size() const;
  public:
  void clear_longs();
  private:
  int64_t _internal_longs(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_longs() const;
  void _internal_add_longs(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_longs();
  public:
  int64_t longs(int index) const;
  void set_longs(int index, int64_t value);
  void add_longs(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      longs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_longs();

  // repeated double float64s = 16;
  int float64s_size() const;
  private:
  int _internal_float64s_size() const;
  public:
  void clear_float64s();
  private:
  double _internal_float64s(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_float64s() const;
  void _internal_add_float64s(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_float64s();
  public:
  double float64s(int index) const;
  void set_float64s(int index, double value);
  void add_float64s(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      float64s() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_float64s();

  // repeated string vars_name = 18;
  int vars_name_size() const;
  private:
  int _internal_vars_name_size() const;
  public:
  void clear_vars_name();
  const std::string& vars_name(int index) const;
  std::string* mutable_vars_name(int index);
  void set_vars_name(int index, const std::string& value);
  void set_vars_name(int index, std::string&& value);
  void set_vars_name(int index, const char* value);
  void set_vars_name(int index, const char* value, size_t size);
  std::string* add_vars_name();
  void add_vars_name(const std::string& value);
  void add_vars_name(std::string&& value);
  void add_vars_name(const char* value);
  void add_vars_name(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& vars_name() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_vars_name();
  private:
  const std::string& _internal_vars_name(int index) const;
  std::string* _internal_add_vars_name();
  public:

  // repeated .paddle.framework.proto.Scalar scalars = 21;
  int scalars_size() const;
  private:
  int _internal_scalars_size() const;
  public:
  void clear_scalars();
  ::paddle::framework::proto::Scalar* mutable_scalars(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::Scalar >*
      mutable_scalars();
  private:
  const ::paddle::framework::proto::Scalar& _internal_scalars(int index) const;
  ::paddle::framework::proto::Scalar* _internal_add_scalars();
  public:
  const ::paddle::framework::proto::Scalar& scalars(int index) const;
  ::paddle::framework::proto::Scalar* add_scalars();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::Scalar >&
      scalars() const;

  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string s = 5;
  bool has_s() const;
  private:
  bool _internal_has_s() const;
  public:
  void clear_s();
  const std::string& s() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s();
  PROTOBUF_NODISCARD std::string* release_s();
  void set_allocated_s(std::string* s);
  private:
  const std::string& _internal_s() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s(const std::string& value);
  std::string* _internal_mutable_s();
  public:

  // optional string var_name = 17;
  bool has_var_name() const;
  private:
  bool _internal_has_var_name() const;
  public:
  void clear_var_name();
  const std::string& var_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_var_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_var_name();
  PROTOBUF_NODISCARD std::string* release_var_name();
  void set_allocated_var_name(std::string* var_name);
  private:
  const std::string& _internal_var_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_var_name(const std::string& value);
  std::string* _internal_mutable_var_name();
  public:

  // optional .paddle.framework.proto.Scalar scalar = 20;
  bool has_scalar() const;
  private:
  bool _internal_has_scalar() const;
  public:
  void clear_scalar();
  const ::paddle::framework::proto::Scalar& scalar() const;
  PROTOBUF_NODISCARD ::paddle::framework::proto::Scalar* release_scalar();
  ::paddle::framework::proto::Scalar* mutable_scalar();
  void set_allocated_scalar(::paddle::framework::proto::Scalar* scalar);
  private:
  const ::paddle::framework::proto::Scalar& _internal_scalar() const;
  ::paddle::framework::proto::Scalar* _internal_mutable_scalar();
  public:
  void unsafe_arena_set_allocated_scalar(
      ::paddle::framework::proto::Scalar* scalar);
  ::paddle::framework::proto::Scalar* unsafe_arena_release_scalar();

  // required .paddle.framework.proto.AttrType type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::paddle::framework::proto::AttrType type() const;
  void set_type(::paddle::framework::proto::AttrType value);
  private:
  ::paddle::framework::proto::AttrType _internal_type() const;
  void _internal_set_type(::paddle::framework::proto::AttrType value);
  public:

  // optional int32 i = 3;
  bool has_i() const;
  private:
  bool _internal_has_i() const;
  public:
  void clear_i();
  int32_t i() const;
  void set_i(int32_t value);
  private:
  int32_t _internal_i() const;
  void _internal_set_i(int32_t value);
  public:

  // optional float f = 4;
  bool has_f() const;
  private:
  bool _internal_has_f() const;
  public:
  void clear_f();
  float f() const;
  void set_f(float value);
  private:
  float _internal_f() const;
  void _internal_set_f(float value);
  public:

  // optional bool b = 10;
  bool has_b() const;
  private:
  bool _internal_has_b() const;
  public:
  void clear_b();
  bool b() const;
  void set_b(bool value);
  private:
  bool _internal_b() const;
  void _internal_set_b(bool value);
  public:

  // optional int64 l = 13;
  bool has_l() const;
  private:
  bool _internal_has_l() const;
  public:
  void clear_l();
  int64_t l() const;
  void set_l(int64_t value);
  private:
  int64_t _internal_l() const;
  void _internal_set_l(int64_t value);
  public:

  // optional double float64 = 19;
  bool has_float64() const;
  private:
  bool _internal_has_float64() const;
  public:
  void clear_float64();
  double float64() const;
  void set_float64(double value);
  private:
  double _internal_float64() const;
  void _internal_set_float64(double value);
  public:

  // optional int32 block_idx = 12;
  bool has_block_idx() const;
  private:
  bool _internal_has_block_idx() const;
  public:
  void clear_block_idx();
  int32_t block_idx() const;
  void set_block_idx(int32_t value);
  private:
  int32_t _internal_block_idx() const;
  void _internal_set_block_idx(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:paddle.framework.proto.OpDesc.Attr)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > ints_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > floats_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> strings_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > bools_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > blocks_idx_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > longs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > float64s_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> vars_name_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::Scalar > scalars_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr var_name_;
    ::paddle::framework::proto::Scalar* scalar_;
    int type_;
    int32_t i_;
    float f_;
    bool b_;
    int64_t l_;
    double float64_;
    int32_t block_idx_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_paddle_2fphi_2fcore_2fframework_2fframework_2eproto;
};
// -------------------------------------------------------------------

class OpDesc_Var final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:paddle.framework.proto.OpDesc.Var) */ {
 public:
  inline OpDesc_Var() : OpDesc_Var(nullptr) {}
  ~OpDesc_Var() override;
  explicit PROTOBUF_CONSTEXPR OpDesc_Var(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpDesc_Var(const OpDesc_Var& from);
  OpDesc_Var(OpDesc_Var&& from) noexcept
    : OpDesc_Var() {
    *this = ::std::move(from);
  }

  inline OpDesc_Var& operator=(const OpDesc_Var& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpDesc_Var& operator=(OpDesc_Var&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpDesc_Var& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpDesc_Var* internal_default_instance() {
    return reinterpret_cast<const OpDesc_Var*>(
               &_OpDesc_Var_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(OpDesc_Var& a, OpDesc_Var& b) {
    a.Swap(&b);
  }
  inline void Swap(OpDesc_Var* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpDesc_Var* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpDesc_Var* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpDesc_Var>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpDesc_Var& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpDesc_Var& from) {
    OpDesc_Var::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpDesc_Var* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "paddle.framework.proto.OpDesc.Var";
  }
  protected:
  explicit OpDesc_Var(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgumentsFieldNumber = 2,
    kParameterFieldNumber = 1,
  };
  // repeated string arguments = 2;
  int arguments_size() const;
  private:
  int _internal_arguments_size() const;
  public:
  void clear_arguments();
  const std::string& arguments(int index) const;
  std::string* mutable_arguments(int index);
  void set_arguments(int index, const std::string& value);
  void set_arguments(int index, std::string&& value);
  void set_arguments(int index, const char* value);
  void set_arguments(int index, const char* value, size_t size);
  std::string* add_arguments();
  void add_arguments(const std::string& value);
  void add_arguments(std::string&& value);
  void add_arguments(const char* value);
  void add_arguments(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& arguments() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_arguments();
  private:
  const std::string& _internal_arguments(int index) const;
  std::string* _internal_add_arguments();
  public:

  // required string parameter = 1;
  bool has_parameter() const;
  private:
  bool _internal_has_parameter() const;
  public:
  void clear_parameter();
  const std::string& parameter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parameter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parameter();
  PROTOBUF_NODISCARD std::string* release_parameter();
  void set_allocated_parameter(std::string* parameter);
  private:
  const std::string& _internal_parameter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parameter(const std::string& value);
  std::string* _internal_mutable_parameter();
  public:

  // @@protoc_insertion_point(class_scope:paddle.framework.proto.OpDesc.Var)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> arguments_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parameter_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_paddle_2fphi_2fcore_2fframework_2fframework_2eproto;
};
// -------------------------------------------------------------------

class OpDesc final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:paddle.framework.proto.OpDesc) */ {
 public:
  inline OpDesc() : OpDesc(nullptr) {}
  ~OpDesc() override;
  explicit PROTOBUF_CONSTEXPR OpDesc(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpDesc(const OpDesc& from);
  OpDesc(OpDesc&& from) noexcept
    : OpDesc() {
    *this = ::std::move(from);
  }

  inline OpDesc& operator=(const OpDesc& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpDesc& operator=(OpDesc&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpDesc& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpDesc* internal_default_instance() {
    return reinterpret_cast<const OpDesc*>(
               &_OpDesc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(OpDesc& a, OpDesc& b) {
    a.Swap(&b);
  }
  inline void Swap(OpDesc* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpDesc* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpDesc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpDesc>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpDesc& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpDesc& from) {
    OpDesc::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpDesc* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "paddle.framework.proto.OpDesc";
  }
  protected:
  explicit OpDesc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef OpDesc_Attr Attr;
  typedef OpDesc_Var Var;

  // accessors -------------------------------------------------------

  enum : int {
    kInputsFieldNumber = 1,
    kOutputsFieldNumber = 2,
    kAttrsFieldNumber = 4,
    kTypeFieldNumber = 3,
    kIsTargetFieldNumber = 5,
  };
  // repeated .paddle.framework.proto.OpDesc.Var inputs = 1;
  int inputs_size() const;
  private:
  int _internal_inputs_size() const;
  public:
  void clear_inputs();
  ::paddle::framework::proto::OpDesc_Var* mutable_inputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpDesc_Var >*
      mutable_inputs();
  private:
  const ::paddle::framework::proto::OpDesc_Var& _internal_inputs(int index) const;
  ::paddle::framework::proto::OpDesc_Var* _internal_add_inputs();
  public:
  const ::paddle::framework::proto::OpDesc_Var& inputs(int index) const;
  ::paddle::framework::proto::OpDesc_Var* add_inputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpDesc_Var >&
      inputs() const;

  // repeated .paddle.framework.proto.OpDesc.Var outputs = 2;
  int outputs_size() const;
  private:
  int _internal_outputs_size() const;
  public:
  void clear_outputs();
  ::paddle::framework::proto::OpDesc_Var* mutable_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpDesc_Var >*
      mutable_outputs();
  private:
  const ::paddle::framework::proto::OpDesc_Var& _internal_outputs(int index) const;
  ::paddle::framework::proto::OpDesc_Var* _internal_add_outputs();
  public:
  const ::paddle::framework::proto::OpDesc_Var& outputs(int index) const;
  ::paddle::framework::proto::OpDesc_Var* add_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpDesc_Var >&
      outputs() const;

  // repeated .paddle.framework.proto.OpDesc.Attr attrs = 4;
  int attrs_size() const;
  private:
  int _internal_attrs_size() const;
  public:
  void clear_attrs();
  ::paddle::framework::proto::OpDesc_Attr* mutable_attrs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpDesc_Attr >*
      mutable_attrs();
  private:
  const ::paddle::framework::proto::OpDesc_Attr& _internal_attrs(int index) const;
  ::paddle::framework::proto::OpDesc_Attr* _internal_add_attrs();
  public:
  const ::paddle::framework::proto::OpDesc_Attr& attrs(int index) const;
  ::paddle::framework::proto::OpDesc_Attr* add_attrs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpDesc_Attr >&
      attrs() const;

  // required string type = 3;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // optional bool is_target = 5 [default = false];
  bool has_is_target() const;
  private:
  bool _internal_has_is_target() const;
  public:
  void clear_is_target();
  bool is_target() const;
  void set_is_target(bool value);
  private:
  bool _internal_is_target() const;
  void _internal_set_is_target(bool value);
  public:

  // @@protoc_insertion_point(class_scope:paddle.framework.proto.OpDesc)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpDesc_Var > inputs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpDesc_Var > outputs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpDesc_Attr > attrs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    bool is_target_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_paddle_2fphi_2fcore_2fframework_2fframework_2eproto;
};
// -------------------------------------------------------------------

class OpProto_Var final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:paddle.framework.proto.OpProto.Var) */ {
 public:
  inline OpProto_Var() : OpProto_Var(nullptr) {}
  ~OpProto_Var() override;
  explicit PROTOBUF_CONSTEXPR OpProto_Var(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpProto_Var(const OpProto_Var& from);
  OpProto_Var(OpProto_Var&& from) noexcept
    : OpProto_Var() {
    *this = ::std::move(from);
  }

  inline OpProto_Var& operator=(const OpProto_Var& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpProto_Var& operator=(OpProto_Var&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpProto_Var& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpProto_Var* internal_default_instance() {
    return reinterpret_cast<const OpProto_Var*>(
               &_OpProto_Var_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(OpProto_Var& a, OpProto_Var& b) {
    a.Swap(&b);
  }
  inline void Swap(OpProto_Var* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpProto_Var* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpProto_Var* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpProto_Var>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpProto_Var& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpProto_Var& from) {
    OpProto_Var::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpProto_Var* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "paddle.framework.proto.OpProto.Var";
  }
  protected:
  explicit OpProto_Var(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kCommentFieldNumber = 2,
    kDuplicableFieldNumber = 3,
    kIntermediateFieldNumber = 4,
    kDispensableFieldNumber = 5,
    kExtraFieldNumber = 6,
    kQuantFieldNumber = 7,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required string comment = 2;
  bool has_comment() const;
  private:
  bool _internal_has_comment() const;
  public:
  void clear_comment();
  const std::string& comment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* comment);
  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
  std::string* _internal_mutable_comment();
  public:

  // optional bool duplicable = 3 [default = false];
  bool has_duplicable() const;
  private:
  bool _internal_has_duplicable() const;
  public:
  void clear_duplicable();
  bool duplicable() const;
  void set_duplicable(bool value);
  private:
  bool _internal_duplicable() const;
  void _internal_set_duplicable(bool value);
  public:

  // optional bool intermediate = 4 [default = false];
  bool has_intermediate() const;
  private:
  bool _internal_has_intermediate() const;
  public:
  void clear_intermediate();
  bool intermediate() const;
  void set_intermediate(bool value);
  private:
  bool _internal_intermediate() const;
  void _internal_set_intermediate(bool value);
  public:

  // optional bool dispensable = 5 [default = false];
  bool has_dispensable() const;
  private:
  bool _internal_has_dispensable() const;
  public:
  void clear_dispensable();
  bool dispensable() const;
  void set_dispensable(bool value);
  private:
  bool _internal_dispensable() const;
  void _internal_set_dispensable(bool value);
  public:

  // optional bool extra = 6 [default = false];
  bool has_extra() const;
  private:
  bool _internal_has_extra() const;
  public:
  void clear_extra();
  bool extra() const;
  void set_extra(bool value);
  private:
  bool _internal_extra() const;
  void _internal_set_extra(bool value);
  public:

  // optional bool quant = 7 [default = false];
  bool has_quant() const;
  private:
  bool _internal_has_quant() const;
  public:
  void clear_quant();
  bool quant() const;
  void set_quant(bool value);
  private:
  bool _internal_quant() const;
  void _internal_set_quant(bool value);
  public:

  // @@protoc_insertion_point(class_scope:paddle.framework.proto.OpProto.Var)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
    bool duplicable_;
    bool intermediate_;
    bool dispensable_;
    bool extra_;
    bool quant_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_paddle_2fphi_2fcore_2fframework_2fframework_2eproto;
};
// -------------------------------------------------------------------

class OpProto_Attr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:paddle.framework.proto.OpProto.Attr) */ {
 public:
  inline OpProto_Attr() : OpProto_Attr(nullptr) {}
  ~OpProto_Attr() override;
  explicit PROTOBUF_CONSTEXPR OpProto_Attr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpProto_Attr(const OpProto_Attr& from);
  OpProto_Attr(OpProto_Attr&& from) noexcept
    : OpProto_Attr() {
    *this = ::std::move(from);
  }

  inline OpProto_Attr& operator=(const OpProto_Attr& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpProto_Attr& operator=(OpProto_Attr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpProto_Attr& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpProto_Attr* internal_default_instance() {
    return reinterpret_cast<const OpProto_Attr*>(
               &_OpProto_Attr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(OpProto_Attr& a, OpProto_Attr& b) {
    a.Swap(&b);
  }
  inline void Swap(OpProto_Attr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpProto_Attr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpProto_Attr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpProto_Attr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpProto_Attr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpProto_Attr& from) {
    OpProto_Attr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpProto_Attr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "paddle.framework.proto.OpProto.Attr";
  }
  protected:
  explicit OpProto_Attr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kCommentFieldNumber = 3,
    kTypeFieldNumber = 2,
    kGeneratedFieldNumber = 4,
    kExtraFieldNumber = 5,
    kQuantFieldNumber = 6,
    kSupportTensorFieldNumber = 7,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required string comment = 3;
  bool has_comment() const;
  private:
  bool _internal_has_comment() const;
  public:
  void clear_comment();
  const std::string& comment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* comment);
  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
  std::string* _internal_mutable_comment();
  public:

  // required .paddle.framework.proto.AttrType type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::paddle::framework::proto::AttrType type() const;
  void set_type(::paddle::framework::proto::AttrType value);
  private:
  ::paddle::framework::proto::AttrType _internal_type() const;
  void _internal_set_type(::paddle::framework::proto::AttrType value);
  public:

  // optional bool generated = 4 [default = false];
  bool has_generated() const;
  private:
  bool _internal_has_generated() const;
  public:
  void clear_generated();
  bool generated() const;
  void set_generated(bool value);
  private:
  bool _internal_generated() const;
  void _internal_set_generated(bool value);
  public:

  // optional bool extra = 5 [default = false];
  bool has_extra() const;
  private:
  bool _internal_has_extra() const;
  public:
  void clear_extra();
  bool extra() const;
  void set_extra(bool value);
  private:
  bool _internal_extra() const;
  void _internal_set_extra(bool value);
  public:

  // optional bool quant = 6 [default = false];
  bool has_quant() const;
  private:
  bool _internal_has_quant() const;
  public:
  void clear_quant();
  bool quant() const;
  void set_quant(bool value);
  private:
  bool _internal_quant() const;
  void _internal_set_quant(bool value);
  public:

  // optional bool support_tensor = 7 [default = false];
  bool has_support_tensor() const;
  private:
  bool _internal_has_support_tensor() const;
  public:
  void clear_support_tensor();
  bool support_tensor() const;
  void set_support_tensor(bool value);
  private:
  bool _internal_support_tensor() const;
  void _internal_set_support_tensor(bool value);
  public:

  // @@protoc_insertion_point(class_scope:paddle.framework.proto.OpProto.Attr)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
    int type_;
    bool generated_;
    bool extra_;
    bool quant_;
    bool support_tensor_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_paddle_2fphi_2fcore_2fframework_2fframework_2eproto;
};
// -------------------------------------------------------------------

class OpProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:paddle.framework.proto.OpProto) */ {
 public:
  inline OpProto() : OpProto(nullptr) {}
  ~OpProto() override;
  explicit PROTOBUF_CONSTEXPR OpProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpProto(const OpProto& from);
  OpProto(OpProto&& from) noexcept
    : OpProto() {
    *this = ::std::move(from);
  }

  inline OpProto& operator=(const OpProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpProto& operator=(OpProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpProto* internal_default_instance() {
    return reinterpret_cast<const OpProto*>(
               &_OpProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(OpProto& a, OpProto& b) {
    a.Swap(&b);
  }
  inline void Swap(OpProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpProto& from) {
    OpProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "paddle.framework.proto.OpProto";
  }
  protected:
  explicit OpProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef OpProto_Var Var;
  typedef OpProto_Attr Attr;

  // accessors -------------------------------------------------------

  enum : int {
    kInputsFieldNumber = 2,
    kOutputsFieldNumber = 3,
    kAttrsFieldNumber = 4,
    kTypeFieldNumber = 1,
    kCommentFieldNumber = 5,
  };
  // repeated .paddle.framework.proto.OpProto.Var inputs = 2;
  int inputs_size() const;
  private:
  int _internal_inputs_size() const;
  public:
  void clear_inputs();
  ::paddle::framework::proto::OpProto_Var* mutable_inputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpProto_Var >*
      mutable_inputs();
  private:
  const ::paddle::framework::proto::OpProto_Var& _internal_inputs(int index) const;
  ::paddle::framework::proto::OpProto_Var* _internal_add_inputs();
  public:
  const ::paddle::framework::proto::OpProto_Var& inputs(int index) const;
  ::paddle::framework::proto::OpProto_Var* add_inputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpProto_Var >&
      inputs() const;

  // repeated .paddle.framework.proto.OpProto.Var outputs = 3;
  int outputs_size() const;
  private:
  int _internal_outputs_size() const;
  public:
  void clear_outputs();
  ::paddle::framework::proto::OpProto_Var* mutable_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpProto_Var >*
      mutable_outputs();
  private:
  const ::paddle::framework::proto::OpProto_Var& _internal_outputs(int index) const;
  ::paddle::framework::proto::OpProto_Var* _internal_add_outputs();
  public:
  const ::paddle::framework::proto::OpProto_Var& outputs(int index) const;
  ::paddle::framework::proto::OpProto_Var* add_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpProto_Var >&
      outputs() const;

  // repeated .paddle.framework.proto.OpProto.Attr attrs = 4;
  int attrs_size() const;
  private:
  int _internal_attrs_size() const;
  public:
  void clear_attrs();
  ::paddle::framework::proto::OpProto_Attr* mutable_attrs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpProto_Attr >*
      mutable_attrs();
  private:
  const ::paddle::framework::proto::OpProto_Attr& _internal_attrs(int index) const;
  ::paddle::framework::proto::OpProto_Attr* _internal_add_attrs();
  public:
  const ::paddle::framework::proto::OpProto_Attr& attrs(int index) const;
  ::paddle::framework::proto::OpProto_Attr* add_attrs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpProto_Attr >&
      attrs() const;

  // required string type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // required string comment = 5;
  bool has_comment() const;
  private:
  bool _internal_has_comment() const;
  public:
  void clear_comment();
  const std::string& comment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* comment);
  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
  std::string* _internal_mutable_comment();
  public:

  // @@protoc_insertion_point(class_scope:paddle.framework.proto.OpProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpProto_Var > inputs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpProto_Var > outputs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpProto_Attr > attrs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_paddle_2fphi_2fcore_2fframework_2fframework_2eproto;
};
// -------------------------------------------------------------------

class VarType_TensorDesc final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:paddle.framework.proto.VarType.TensorDesc) */ {
 public:
  inline VarType_TensorDesc() : VarType_TensorDesc(nullptr) {}
  ~VarType_TensorDesc() override;
  explicit PROTOBUF_CONSTEXPR VarType_TensorDesc(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VarType_TensorDesc(const VarType_TensorDesc& from);
  VarType_TensorDesc(VarType_TensorDesc&& from) noexcept
    : VarType_TensorDesc() {
    *this = ::std::move(from);
  }

  inline VarType_TensorDesc& operator=(const VarType_TensorDesc& from) {
    CopyFrom(from);
    return *this;
  }
  inline VarType_TensorDesc& operator=(VarType_TensorDesc&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VarType_TensorDesc& default_instance() {
    return *internal_default_instance();
  }
  static inline const VarType_TensorDesc* internal_default_instance() {
    return reinterpret_cast<const VarType_TensorDesc*>(
               &_VarType_TensorDesc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(VarType_TensorDesc& a, VarType_TensorDesc& b) {
    a.Swap(&b);
  }
  inline void Swap(VarType_TensorDesc* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VarType_TensorDesc* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VarType_TensorDesc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VarType_TensorDesc>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VarType_TensorDesc& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VarType_TensorDesc& from) {
    VarType_TensorDesc::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VarType_TensorDesc* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "paddle.framework.proto.VarType.TensorDesc";
  }
  protected:
  explicit VarType_TensorDesc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimsFieldNumber = 2,
    kDataTypeFieldNumber = 1,
  };
  // repeated int64 dims = 2;
  int dims_size() const;
  private:
  int _internal_dims_size() const;
  public:
  void clear_dims();
  private:
  int64_t _internal_dims(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_dims() const;
  void _internal_add_dims(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_dims();
  public:
  int64_t dims(int index) const;
  void set_dims(int index, int64_t value);
  void add_dims(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      dims() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_dims();

  // required .paddle.framework.proto.VarType.Type data_type = 1;
  bool has_data_type() const;
  private:
  bool _internal_has_data_type() const;
  public:
  void clear_data_type();
  ::paddle::framework::proto::VarType_Type data_type() const;
  void set_data_type(::paddle::framework::proto::VarType_Type value);
  private:
  ::paddle::framework::proto::VarType_Type _internal_data_type() const;
  void _internal_set_data_type(::paddle::framework::proto::VarType_Type value);
  public:

  // @@protoc_insertion_point(class_scope:paddle.framework.proto.VarType.TensorDesc)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > dims_;
    int data_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_paddle_2fphi_2fcore_2fframework_2fframework_2eproto;
};
// -------------------------------------------------------------------

class VarType_DenseTensorDesc final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:paddle.framework.proto.VarType.DenseTensorDesc) */ {
 public:
  inline VarType_DenseTensorDesc() : VarType_DenseTensorDesc(nullptr) {}
  ~VarType_DenseTensorDesc() override;
  explicit PROTOBUF_CONSTEXPR VarType_DenseTensorDesc(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VarType_DenseTensorDesc(const VarType_DenseTensorDesc& from);
  VarType_DenseTensorDesc(VarType_DenseTensorDesc&& from) noexcept
    : VarType_DenseTensorDesc() {
    *this = ::std::move(from);
  }

  inline VarType_DenseTensorDesc& operator=(const VarType_DenseTensorDesc& from) {
    CopyFrom(from);
    return *this;
  }
  inline VarType_DenseTensorDesc& operator=(VarType_DenseTensorDesc&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VarType_DenseTensorDesc& default_instance() {
    return *internal_default_instance();
  }
  static inline const VarType_DenseTensorDesc* internal_default_instance() {
    return reinterpret_cast<const VarType_DenseTensorDesc*>(
               &_VarType_DenseTensorDesc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(VarType_DenseTensorDesc& a, VarType_DenseTensorDesc& b) {
    a.Swap(&b);
  }
  inline void Swap(VarType_DenseTensorDesc* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VarType_DenseTensorDesc* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VarType_DenseTensorDesc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VarType_DenseTensorDesc>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VarType_DenseTensorDesc& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VarType_DenseTensorDesc& from) {
    VarType_DenseTensorDesc::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VarType_DenseTensorDesc* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "paddle.framework.proto.VarType.DenseTensorDesc";
  }
  protected:
  explicit VarType_DenseTensorDesc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTensorFieldNumber = 1,
    kLegacyLodLevelFieldNumber = 2,
  };
  // required .paddle.framework.proto.VarType.TensorDesc tensor = 1;
  bool has_tensor() const;
  private:
  bool _internal_has_tensor() const;
  public:
  void clear_tensor();
  const ::paddle::framework::proto::VarType_TensorDesc& tensor() const;
  PROTOBUF_NODISCARD ::paddle::framework::proto::VarType_TensorDesc* release_tensor();
  ::paddle::framework::proto::VarType_TensorDesc* mutable_tensor();
  void set_allocated_tensor(::paddle::framework::proto::VarType_TensorDesc* tensor);
  private:
  const ::paddle::framework::proto::VarType_TensorDesc& _internal_tensor() const;
  ::paddle::framework::proto::VarType_TensorDesc* _internal_mutable_tensor();
  public:
  void unsafe_arena_set_allocated_tensor(
      ::paddle::framework::proto::VarType_TensorDesc* tensor);
  ::paddle::framework::proto::VarType_TensorDesc* unsafe_arena_release_tensor();

  // optional int32 legacy_lod_level = 2 [default = 0];
  bool has_legacy_lod_level() const;
  private:
  bool _internal_has_legacy_lod_level() const;
  public:
  void clear_legacy_lod_level();
  int32_t legacy_lod_level() const;
  void set_legacy_lod_level(int32_t value);
  private:
  int32_t _internal_legacy_lod_level() const;
  void _internal_set_legacy_lod_level(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:paddle.framework.proto.VarType.DenseTensorDesc)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::paddle::framework::proto::VarType_TensorDesc* tensor_;
    int32_t legacy_lod_level_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_paddle_2fphi_2fcore_2fframework_2fframework_2eproto;
};
// -------------------------------------------------------------------

class VarType_DenseTensorArrayDesc final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:paddle.framework.proto.VarType.DenseTensorArrayDesc) */ {
 public:
  inline VarType_DenseTensorArrayDesc() : VarType_DenseTensorArrayDesc(nullptr) {}
  ~VarType_DenseTensorArrayDesc() override;
  explicit PROTOBUF_CONSTEXPR VarType_DenseTensorArrayDesc(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VarType_DenseTensorArrayDesc(const VarType_DenseTensorArrayDesc& from);
  VarType_DenseTensorArrayDesc(VarType_DenseTensorArrayDesc&& from) noexcept
    : VarType_DenseTensorArrayDesc() {
    *this = ::std::move(from);
  }

  inline VarType_DenseTensorArrayDesc& operator=(const VarType_DenseTensorArrayDesc& from) {
    CopyFrom(from);
    return *this;
  }
  inline VarType_DenseTensorArrayDesc& operator=(VarType_DenseTensorArrayDesc&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VarType_DenseTensorArrayDesc& default_instance() {
    return *internal_default_instance();
  }
  static inline const VarType_DenseTensorArrayDesc* internal_default_instance() {
    return reinterpret_cast<const VarType_DenseTensorArrayDesc*>(
               &_VarType_DenseTensorArrayDesc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(VarType_DenseTensorArrayDesc& a, VarType_DenseTensorArrayDesc& b) {
    a.Swap(&b);
  }
  inline void Swap(VarType_DenseTensorArrayDesc* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VarType_DenseTensorArrayDesc* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VarType_DenseTensorArrayDesc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VarType_DenseTensorArrayDesc>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VarType_DenseTensorArrayDesc& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VarType_DenseTensorArrayDesc& from) {
    VarType_DenseTensorArrayDesc::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VarType_DenseTensorArrayDesc* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "paddle.framework.proto.VarType.DenseTensorArrayDesc";
  }
  protected:
  explicit VarType_DenseTensorArrayDesc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTensorFieldNumber = 1,
    kLegacyLodLevelFieldNumber = 2,
  };
  // required .paddle.framework.proto.VarType.TensorDesc tensor = 1;
  bool has_tensor() const;
  private:
  bool _internal_has_tensor() const;
  public:
  void clear_tensor();
  const ::paddle::framework::proto::VarType_TensorDesc& tensor() const;
  PROTOBUF_NODISCARD ::paddle::framework::proto::VarType_TensorDesc* release_tensor();
  ::paddle::framework::proto::VarType_TensorDesc* mutable_tensor();
  void set_allocated_tensor(::paddle::framework::proto::VarType_TensorDesc* tensor);
  private:
  const ::paddle::framework::proto::VarType_TensorDesc& _internal_tensor() const;
  ::paddle::framework::proto::VarType_TensorDesc* _internal_mutable_tensor();
  public:
  void unsafe_arena_set_allocated_tensor(
      ::paddle::framework::proto::VarType_TensorDesc* tensor);
  ::paddle::framework::proto::VarType_TensorDesc* unsafe_arena_release_tensor();

  // optional int32 legacy_lod_level = 2 [default = 0];
  bool has_legacy_lod_level() const;
  private:
  bool _internal_has_legacy_lod_level() const;
  public:
  void clear_legacy_lod_level();
  int32_t legacy_lod_level() const;
  void set_legacy_lod_level(int32_t value);
  private:
  int32_t _internal_legacy_lod_level() const;
  void _internal_set_legacy_lod_level(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:paddle.framework.proto.VarType.DenseTensorArrayDesc)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::paddle::framework::proto::VarType_TensorDesc* tensor_;
    int32_t legacy_lod_level_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_paddle_2fphi_2fcore_2fframework_2fframework_2eproto;
};
// -------------------------------------------------------------------

class VarType_ReaderDesc final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:paddle.framework.proto.VarType.ReaderDesc) */ {
 public:
  inline VarType_ReaderDesc() : VarType_ReaderDesc(nullptr) {}
  ~VarType_ReaderDesc() override;
  explicit PROTOBUF_CONSTEXPR VarType_ReaderDesc(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VarType_ReaderDesc(const VarType_ReaderDesc& from);
  VarType_ReaderDesc(VarType_ReaderDesc&& from) noexcept
    : VarType_ReaderDesc() {
    *this = ::std::move(from);
  }

  inline VarType_ReaderDesc& operator=(const VarType_ReaderDesc& from) {
    CopyFrom(from);
    return *this;
  }
  inline VarType_ReaderDesc& operator=(VarType_ReaderDesc&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VarType_ReaderDesc& default_instance() {
    return *internal_default_instance();
  }
  static inline const VarType_ReaderDesc* internal_default_instance() {
    return reinterpret_cast<const VarType_ReaderDesc*>(
               &_VarType_ReaderDesc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(VarType_ReaderDesc& a, VarType_ReaderDesc& b) {
    a.Swap(&b);
  }
  inline void Swap(VarType_ReaderDesc* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VarType_ReaderDesc* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VarType_ReaderDesc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VarType_ReaderDesc>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VarType_ReaderDesc& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VarType_ReaderDesc& from) {
    VarType_ReaderDesc::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VarType_ReaderDesc* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "paddle.framework.proto.VarType.ReaderDesc";
  }
  protected:
  explicit VarType_ReaderDesc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDenseTensorFieldNumber = 1,
  };
  // repeated .paddle.framework.proto.VarType.DenseTensorDesc dense_tensor = 1;
  int dense_tensor_size() const;
  private:
  int _internal_dense_tensor_size() const;
  public:
  void clear_dense_tensor();
  ::paddle::framework::proto::VarType_DenseTensorDesc* mutable_dense_tensor(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::VarType_DenseTensorDesc >*
      mutable_dense_tensor();
  private:
  const ::paddle::framework::proto::VarType_DenseTensorDesc& _internal_dense_tensor(int index) const;
  ::paddle::framework::proto::VarType_DenseTensorDesc* _internal_add_dense_tensor();
  public:
  const ::paddle::framework::proto::VarType_DenseTensorDesc& dense_tensor(int index) const;
  ::paddle::framework::proto::VarType_DenseTensorDesc* add_dense_tensor();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::VarType_DenseTensorDesc >&
      dense_tensor() const;

  // @@protoc_insertion_point(class_scope:paddle.framework.proto.VarType.ReaderDesc)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::VarType_DenseTensorDesc > dense_tensor_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_paddle_2fphi_2fcore_2fframework_2fframework_2eproto;
};
// -------------------------------------------------------------------

class VarType_Tuple final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:paddle.framework.proto.VarType.Tuple) */ {
 public:
  inline VarType_Tuple() : VarType_Tuple(nullptr) {}
  ~VarType_Tuple() override;
  explicit PROTOBUF_CONSTEXPR VarType_Tuple(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VarType_Tuple(const VarType_Tuple& from);
  VarType_Tuple(VarType_Tuple&& from) noexcept
    : VarType_Tuple() {
    *this = ::std::move(from);
  }

  inline VarType_Tuple& operator=(const VarType_Tuple& from) {
    CopyFrom(from);
    return *this;
  }
  inline VarType_Tuple& operator=(VarType_Tuple&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VarType_Tuple& default_instance() {
    return *internal_default_instance();
  }
  static inline const VarType_Tuple* internal_default_instance() {
    return reinterpret_cast<const VarType_Tuple*>(
               &_VarType_Tuple_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(VarType_Tuple& a, VarType_Tuple& b) {
    a.Swap(&b);
  }
  inline void Swap(VarType_Tuple* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VarType_Tuple* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VarType_Tuple* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VarType_Tuple>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VarType_Tuple& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VarType_Tuple& from) {
    VarType_Tuple::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VarType_Tuple* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "paddle.framework.proto.VarType.Tuple";
  }
  protected:
  explicit VarType_Tuple(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kElementTypeFieldNumber = 1,
  };
  // repeated .paddle.framework.proto.VarType.Type element_type = 1;
  int element_type_size() const;
  private:
  int _internal_element_type_size() const;
  public:
  void clear_element_type();
  private:
  ::paddle::framework::proto::VarType_Type _internal_element_type(int index) const;
  void _internal_add_element_type(::paddle::framework::proto::VarType_Type value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_element_type();
  public:
  ::paddle::framework::proto::VarType_Type element_type(int index) const;
  void set_element_type(int index, ::paddle::framework::proto::VarType_Type value);
  void add_element_type(::paddle::framework::proto::VarType_Type value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& element_type() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_element_type();

  // @@protoc_insertion_point(class_scope:paddle.framework.proto.VarType.Tuple)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> element_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_paddle_2fphi_2fcore_2fframework_2fframework_2eproto;
};
// -------------------------------------------------------------------

class VarType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:paddle.framework.proto.VarType) */ {
 public:
  inline VarType() : VarType(nullptr) {}
  ~VarType() override;
  explicit PROTOBUF_CONSTEXPR VarType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VarType(const VarType& from);
  VarType(VarType&& from) noexcept
    : VarType() {
    *this = ::std::move(from);
  }

  inline VarType& operator=(const VarType& from) {
    CopyFrom(from);
    return *this;
  }
  inline VarType& operator=(VarType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VarType& default_instance() {
    return *internal_default_instance();
  }
  static inline const VarType* internal_default_instance() {
    return reinterpret_cast<const VarType*>(
               &_VarType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(VarType& a, VarType& b) {
    a.Swap(&b);
  }
  inline void Swap(VarType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VarType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VarType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VarType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VarType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VarType& from) {
    VarType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VarType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "paddle.framework.proto.VarType";
  }
  protected:
  explicit VarType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VarType_TensorDesc TensorDesc;
  typedef VarType_DenseTensorDesc DenseTensorDesc;
  typedef VarType_DenseTensorArrayDesc DenseTensorArrayDesc;
  typedef VarType_ReaderDesc ReaderDesc;
  typedef VarType_Tuple Tuple;

  typedef VarType_Type Type;
  static constexpr Type BOOL =
    VarType_Type_BOOL;
  static constexpr Type INT16 =
    VarType_Type_INT16;
  static constexpr Type INT32 =
    VarType_Type_INT32;
  static constexpr Type INT64 =
    VarType_Type_INT64;
  static constexpr Type FP16 =
    VarType_Type_FP16;
  static constexpr Type FP32 =
    VarType_Type_FP32;
  static constexpr Type FP64 =
    VarType_Type_FP64;
  static constexpr Type SIZE_T =
    VarType_Type_SIZE_T;
  static constexpr Type UINT8 =
    VarType_Type_UINT8;
  static constexpr Type INT8 =
    VarType_Type_INT8;
  static constexpr Type BF16 =
    VarType_Type_BF16;
  static constexpr Type COMPLEX64 =
    VarType_Type_COMPLEX64;
  static constexpr Type COMPLEX128 =
    VarType_Type_COMPLEX128;
  static constexpr Type FP8_E4M3FN =
    VarType_Type_FP8_E4M3FN;
  static constexpr Type FP8_E5M2 =
    VarType_Type_FP8_E5M2;
  static constexpr Type DENSE_TENSOR =
    VarType_Type_DENSE_TENSOR;
  static constexpr Type SELECTED_ROWS =
    VarType_Type_SELECTED_ROWS;
  static constexpr Type FEED_MINIBATCH =
    VarType_Type_FEED_MINIBATCH;
  static constexpr Type FETCH_LIST =
    VarType_Type_FETCH_LIST;
  static constexpr Type STEP_SCOPES =
    VarType_Type_STEP_SCOPES;
  static constexpr Type LOD_RANK_TABLE =
    VarType_Type_LOD_RANK_TABLE;
  static constexpr Type DENSE_TENSOR_ARRAY =
    VarType_Type_DENSE_TENSOR_ARRAY;
  static constexpr Type PLACE_LIST =
    VarType_Type_PLACE_LIST;
  static constexpr Type READER =
    VarType_Type_READER;
  static constexpr Type RAW =
    VarType_Type_RAW;
  static constexpr Type TUPLE =
    VarType_Type_TUPLE;
  static constexpr Type STRING =
    VarType_Type_STRING;
  static constexpr Type STRINGS =
    VarType_Type_STRINGS;
  static constexpr Type VOCAB =
    VarType_Type_VOCAB;
  static constexpr Type FEED_LIST =
    VarType_Type_FEED_LIST;
  static constexpr Type PSTRING =
    VarType_Type_PSTRING;
  static constexpr Type SPARSE_COO =
    VarType_Type_SPARSE_COO;
  static constexpr Type SPARSE_CSR =
    VarType_Type_SPARSE_CSR;
  static inline bool Type_IsValid(int value) {
    return VarType_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    VarType_Type_Type_MIN;
  static constexpr Type Type_MAX =
    VarType_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    VarType_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return VarType_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return VarType_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return VarType_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSelectedRowsFieldNumber = 2,
    kDenseTensorFieldNumber = 3,
    kTensorArrayFieldNumber = 4,
    kReaderFieldNumber = 5,
    kTupleFieldNumber = 7,
    kStringFieldNumber = 8,
    kStringsFieldNumber = 9,
    kVocabFieldNumber = 10,
    kSparseCooFieldNumber = 11,
    kSparseCsrFieldNumber = 12,
    kTypeFieldNumber = 1,
  };
  // optional .paddle.framework.proto.VarType.TensorDesc selected_rows = 2;
  bool has_selected_rows() const;
  private:
  bool _internal_has_selected_rows() const;
  public:
  void clear_selected_rows();
  const ::paddle::framework::proto::VarType_TensorDesc& selected_rows() const;
  PROTOBUF_NODISCARD ::paddle::framework::proto::VarType_TensorDesc* release_selected_rows();
  ::paddle::framework::proto::VarType_TensorDesc* mutable_selected_rows();
  void set_allocated_selected_rows(::paddle::framework::proto::VarType_TensorDesc* selected_rows);
  private:
  const ::paddle::framework::proto::VarType_TensorDesc& _internal_selected_rows() const;
  ::paddle::framework::proto::VarType_TensorDesc* _internal_mutable_selected_rows();
  public:
  void unsafe_arena_set_allocated_selected_rows(
      ::paddle::framework::proto::VarType_TensorDesc* selected_rows);
  ::paddle::framework::proto::VarType_TensorDesc* unsafe_arena_release_selected_rows();

  // optional .paddle.framework.proto.VarType.DenseTensorDesc dense_tensor = 3;
  bool has_dense_tensor() const;
  private:
  bool _internal_has_dense_tensor() const;
  public:
  void clear_dense_tensor();
  const ::paddle::framework::proto::VarType_DenseTensorDesc& dense_tensor() const;
  PROTOBUF_NODISCARD ::paddle::framework::proto::VarType_DenseTensorDesc* release_dense_tensor();
  ::paddle::framework::proto::VarType_DenseTensorDesc* mutable_dense_tensor();
  void set_allocated_dense_tensor(::paddle::framework::proto::VarType_DenseTensorDesc* dense_tensor);
  private:
  const ::paddle::framework::proto::VarType_DenseTensorDesc& _internal_dense_tensor() const;
  ::paddle::framework::proto::VarType_DenseTensorDesc* _internal_mutable_dense_tensor();
  public:
  void unsafe_arena_set_allocated_dense_tensor(
      ::paddle::framework::proto::VarType_DenseTensorDesc* dense_tensor);
  ::paddle::framework::proto::VarType_DenseTensorDesc* unsafe_arena_release_dense_tensor();

  // optional .paddle.framework.proto.VarType.DenseTensorArrayDesc tensor_array = 4;
  bool has_tensor_array() const;
  private:
  bool _internal_has_tensor_array() const;
  public:
  void clear_tensor_array();
  const ::paddle::framework::proto::VarType_DenseTensorArrayDesc& tensor_array() const;
  PROTOBUF_NODISCARD ::paddle::framework::proto::VarType_DenseTensorArrayDesc* release_tensor_array();
  ::paddle::framework::proto::VarType_DenseTensorArrayDesc* mutable_tensor_array();
  void set_allocated_tensor_array(::paddle::framework::proto::VarType_DenseTensorArrayDesc* tensor_array);
  private:
  const ::paddle::framework::proto::VarType_DenseTensorArrayDesc& _internal_tensor_array() const;
  ::paddle::framework::proto::VarType_DenseTensorArrayDesc* _internal_mutable_tensor_array();
  public:
  void unsafe_arena_set_allocated_tensor_array(
      ::paddle::framework::proto::VarType_DenseTensorArrayDesc* tensor_array);
  ::paddle::framework::proto::VarType_DenseTensorArrayDesc* unsafe_arena_release_tensor_array();

  // optional .paddle.framework.proto.VarType.ReaderDesc reader = 5;
  bool has_reader() const;
  private:
  bool _internal_has_reader() const;
  public:
  void clear_reader();
  const ::paddle::framework::proto::VarType_ReaderDesc& reader() const;
  PROTOBUF_NODISCARD ::paddle::framework::proto::VarType_ReaderDesc* release_reader();
  ::paddle::framework::proto::VarType_ReaderDesc* mutable_reader();
  void set_allocated_reader(::paddle::framework::proto::VarType_ReaderDesc* reader);
  private:
  const ::paddle::framework::proto::VarType_ReaderDesc& _internal_reader() const;
  ::paddle::framework::proto::VarType_ReaderDesc* _internal_mutable_reader();
  public:
  void unsafe_arena_set_allocated_reader(
      ::paddle::framework::proto::VarType_ReaderDesc* reader);
  ::paddle::framework::proto::VarType_ReaderDesc* unsafe_arena_release_reader();

  // optional .paddle.framework.proto.VarType.Tuple tuple = 7;
  bool has_tuple() const;
  private:
  bool _internal_has_tuple() const;
  public:
  void clear_tuple();
  const ::paddle::framework::proto::VarType_Tuple& tuple() const;
  PROTOBUF_NODISCARD ::paddle::framework::proto::VarType_Tuple* release_tuple();
  ::paddle::framework::proto::VarType_Tuple* mutable_tuple();
  void set_allocated_tuple(::paddle::framework::proto::VarType_Tuple* tuple);
  private:
  const ::paddle::framework::proto::VarType_Tuple& _internal_tuple() const;
  ::paddle::framework::proto::VarType_Tuple* _internal_mutable_tuple();
  public:
  void unsafe_arena_set_allocated_tuple(
      ::paddle::framework::proto::VarType_Tuple* tuple);
  ::paddle::framework::proto::VarType_Tuple* unsafe_arena_release_tuple();

  // optional .paddle.framework.proto.VarType.TensorDesc string = 8;
  bool has_string() const;
  private:
  bool _internal_has_string() const;
  public:
  void clear_string();
  const ::paddle::framework::proto::VarType_TensorDesc& string() const;
  PROTOBUF_NODISCARD ::paddle::framework::proto::VarType_TensorDesc* release_string();
  ::paddle::framework::proto::VarType_TensorDesc* mutable_string();
  void set_allocated_string(::paddle::framework::proto::VarType_TensorDesc* string);
  private:
  const ::paddle::framework::proto::VarType_TensorDesc& _internal_string() const;
  ::paddle::framework::proto::VarType_TensorDesc* _internal_mutable_string();
  public:
  void unsafe_arena_set_allocated_string(
      ::paddle::framework::proto::VarType_TensorDesc* string);
  ::paddle::framework::proto::VarType_TensorDesc* unsafe_arena_release_string();

  // optional .paddle.framework.proto.VarType.TensorDesc strings = 9;
  bool has_strings() const;
  private:
  bool _internal_has_strings() const;
  public:
  void clear_strings();
  const ::paddle::framework::proto::VarType_TensorDesc& strings() const;
  PROTOBUF_NODISCARD ::paddle::framework::proto::VarType_TensorDesc* release_strings();
  ::paddle::framework::proto::VarType_TensorDesc* mutable_strings();
  void set_allocated_strings(::paddle::framework::proto::VarType_TensorDesc* strings);
  private:
  const ::paddle::framework::proto::VarType_TensorDesc& _internal_strings() const;
  ::paddle::framework::proto::VarType_TensorDesc* _internal_mutable_strings();
  public:
  void unsafe_arena_set_allocated_strings(
      ::paddle::framework::proto::VarType_TensorDesc* strings);
  ::paddle::framework::proto::VarType_TensorDesc* unsafe_arena_release_strings();

  // optional .paddle.framework.proto.VarType.TensorDesc vocab = 10;
  bool has_vocab() const;
  private:
  bool _internal_has_vocab() const;
  public:
  void clear_vocab();
  const ::paddle::framework::proto::VarType_TensorDesc& vocab() const;
  PROTOBUF_NODISCARD ::paddle::framework::proto::VarType_TensorDesc* release_vocab();
  ::paddle::framework::proto::VarType_TensorDesc* mutable_vocab();
  void set_allocated_vocab(::paddle::framework::proto::VarType_TensorDesc* vocab);
  private:
  const ::paddle::framework::proto::VarType_TensorDesc& _internal_vocab() const;
  ::paddle::framework::proto::VarType_TensorDesc* _internal_mutable_vocab();
  public:
  void unsafe_arena_set_allocated_vocab(
      ::paddle::framework::proto::VarType_TensorDesc* vocab);
  ::paddle::framework::proto::VarType_TensorDesc* unsafe_arena_release_vocab();

  // optional .paddle.framework.proto.VarType.TensorDesc sparse_coo = 11;
  bool has_sparse_coo() const;
  private:
  bool _internal_has_sparse_coo() const;
  public:
  void clear_sparse_coo();
  const ::paddle::framework::proto::VarType_TensorDesc& sparse_coo() const;
  PROTOBUF_NODISCARD ::paddle::framework::proto::VarType_TensorDesc* release_sparse_coo();
  ::paddle::framework::proto::VarType_TensorDesc* mutable_sparse_coo();
  void set_allocated_sparse_coo(::paddle::framework::proto::VarType_TensorDesc* sparse_coo);
  private:
  const ::paddle::framework::proto::VarType_TensorDesc& _internal_sparse_coo() const;
  ::paddle::framework::proto::VarType_TensorDesc* _internal_mutable_sparse_coo();
  public:
  void unsafe_arena_set_allocated_sparse_coo(
      ::paddle::framework::proto::VarType_TensorDesc* sparse_coo);
  ::paddle::framework::proto::VarType_TensorDesc* unsafe_arena_release_sparse_coo();

  // optional .paddle.framework.proto.VarType.TensorDesc sparse_csr = 12;
  bool has_sparse_csr() const;
  private:
  bool _internal_has_sparse_csr() const;
  public:
  void clear_sparse_csr();
  const ::paddle::framework::proto::VarType_TensorDesc& sparse_csr() const;
  PROTOBUF_NODISCARD ::paddle::framework::proto::VarType_TensorDesc* release_sparse_csr();
  ::paddle::framework::proto::VarType_TensorDesc* mutable_sparse_csr();
  void set_allocated_sparse_csr(::paddle::framework::proto::VarType_TensorDesc* sparse_csr);
  private:
  const ::paddle::framework::proto::VarType_TensorDesc& _internal_sparse_csr() const;
  ::paddle::framework::proto::VarType_TensorDesc* _internal_mutable_sparse_csr();
  public:
  void unsafe_arena_set_allocated_sparse_csr(
      ::paddle::framework::proto::VarType_TensorDesc* sparse_csr);
  ::paddle::framework::proto::VarType_TensorDesc* unsafe_arena_release_sparse_csr();

  // required .paddle.framework.proto.VarType.Type type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::paddle::framework::proto::VarType_Type type() const;
  void set_type(::paddle::framework::proto::VarType_Type value);
  private:
  ::paddle::framework::proto::VarType_Type _internal_type() const;
  void _internal_set_type(::paddle::framework::proto::VarType_Type value);
  public:

  // @@protoc_insertion_point(class_scope:paddle.framework.proto.VarType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::paddle::framework::proto::VarType_TensorDesc* selected_rows_;
    ::paddle::framework::proto::VarType_DenseTensorDesc* dense_tensor_;
    ::paddle::framework::proto::VarType_DenseTensorArrayDesc* tensor_array_;
    ::paddle::framework::proto::VarType_ReaderDesc* reader_;
    ::paddle::framework::proto::VarType_Tuple* tuple_;
    ::paddle::framework::proto::VarType_TensorDesc* string_;
    ::paddle::framework::proto::VarType_TensorDesc* strings_;
    ::paddle::framework::proto::VarType_TensorDesc* vocab_;
    ::paddle::framework::proto::VarType_TensorDesc* sparse_coo_;
    ::paddle::framework::proto::VarType_TensorDesc* sparse_csr_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_paddle_2fphi_2fcore_2fframework_2fframework_2eproto;
};
// -------------------------------------------------------------------

class VarDesc_Attr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:paddle.framework.proto.VarDesc.Attr) */ {
 public:
  inline VarDesc_Attr() : VarDesc_Attr(nullptr) {}
  ~VarDesc_Attr() override;
  explicit PROTOBUF_CONSTEXPR VarDesc_Attr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VarDesc_Attr(const VarDesc_Attr& from);
  VarDesc_Attr(VarDesc_Attr&& from) noexcept
    : VarDesc_Attr() {
    *this = ::std::move(from);
  }

  inline VarDesc_Attr& operator=(const VarDesc_Attr& from) {
    CopyFrom(from);
    return *this;
  }
  inline VarDesc_Attr& operator=(VarDesc_Attr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VarDesc_Attr& default_instance() {
    return *internal_default_instance();
  }
  static inline const VarDesc_Attr* internal_default_instance() {
    return reinterpret_cast<const VarDesc_Attr*>(
               &_VarDesc_Attr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(VarDesc_Attr& a, VarDesc_Attr& b) {
    a.Swap(&b);
  }
  inline void Swap(VarDesc_Attr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VarDesc_Attr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VarDesc_Attr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VarDesc_Attr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VarDesc_Attr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VarDesc_Attr& from) {
    VarDesc_Attr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VarDesc_Attr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "paddle.framework.proto.VarDesc.Attr";
  }
  protected:
  explicit VarDesc_Attr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntsFieldNumber = 5,
    kNameFieldNumber = 1,
    kSFieldNumber = 4,
    kTypeFieldNumber = 2,
    kIFieldNumber = 3,
  };
  // repeated int32 ints = 5;
  int ints_size() const;
  private:
  int _internal_ints_size() const;
  public:
  void clear_ints();
  private:
  int32_t _internal_ints(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_ints() const;
  void _internal_add_ints(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_ints();
  public:
  int32_t ints(int index) const;
  void set_ints(int index, int32_t value);
  void add_ints(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      ints() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_ints();

  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string s = 4;
  bool has_s() const;
  private:
  bool _internal_has_s() const;
  public:
  void clear_s();
  const std::string& s() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s();
  PROTOBUF_NODISCARD std::string* release_s();
  void set_allocated_s(std::string* s);
  private:
  const std::string& _internal_s() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s(const std::string& value);
  std::string* _internal_mutable_s();
  public:

  // required .paddle.framework.proto.AttrType type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::paddle::framework::proto::AttrType type() const;
  void set_type(::paddle::framework::proto::AttrType value);
  private:
  ::paddle::framework::proto::AttrType _internal_type() const;
  void _internal_set_type(::paddle::framework::proto::AttrType value);
  public:

  // optional int32 i = 3;
  bool has_i() const;
  private:
  bool _internal_has_i() const;
  public:
  void clear_i();
  int32_t i() const;
  void set_i(int32_t value);
  private:
  int32_t _internal_i() const;
  void _internal_set_i(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:paddle.framework.proto.VarDesc.Attr)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > ints_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_;
    int type_;
    int32_t i_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_paddle_2fphi_2fcore_2fframework_2fframework_2eproto;
};
// -------------------------------------------------------------------

class VarDesc final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:paddle.framework.proto.VarDesc) */ {
 public:
  inline VarDesc() : VarDesc(nullptr) {}
  ~VarDesc() override;
  explicit PROTOBUF_CONSTEXPR VarDesc(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VarDesc(const VarDesc& from);
  VarDesc(VarDesc&& from) noexcept
    : VarDesc() {
    *this = ::std::move(from);
  }

  inline VarDesc& operator=(const VarDesc& from) {
    CopyFrom(from);
    return *this;
  }
  inline VarDesc& operator=(VarDesc&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VarDesc& default_instance() {
    return *internal_default_instance();
  }
  static inline const VarDesc* internal_default_instance() {
    return reinterpret_cast<const VarDesc*>(
               &_VarDesc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(VarDesc& a, VarDesc& b) {
    a.Swap(&b);
  }
  inline void Swap(VarDesc* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VarDesc* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VarDesc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VarDesc>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VarDesc& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VarDesc& from) {
    VarDesc::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VarDesc* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "paddle.framework.proto.VarDesc";
  }
  protected:
  explicit VarDesc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VarDesc_Attr Attr;

  // accessors -------------------------------------------------------

  enum : int {
    kAttrsFieldNumber = 7,
    kNameFieldNumber = 1,
    kTypeFieldNumber = 2,
    kPersistableFieldNumber = 3,
    kNeedCheckFeedFieldNumber = 4,
    kIsParameterFieldNumber = 5,
    kStopGradientFieldNumber = 6,
  };
  // repeated .paddle.framework.proto.VarDesc.Attr attrs = 7;
  int attrs_size() const;
  private:
  int _internal_attrs_size() const;
  public:
  void clear_attrs();
  ::paddle::framework::proto::VarDesc_Attr* mutable_attrs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::VarDesc_Attr >*
      mutable_attrs();
  private:
  const ::paddle::framework::proto::VarDesc_Attr& _internal_attrs(int index) const;
  ::paddle::framework::proto::VarDesc_Attr* _internal_add_attrs();
  public:
  const ::paddle::framework::proto::VarDesc_Attr& attrs(int index) const;
  ::paddle::framework::proto::VarDesc_Attr* add_attrs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::VarDesc_Attr >&
      attrs() const;

  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required .paddle.framework.proto.VarType type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const ::paddle::framework::proto::VarType& type() const;
  PROTOBUF_NODISCARD ::paddle::framework::proto::VarType* release_type();
  ::paddle::framework::proto::VarType* mutable_type();
  void set_allocated_type(::paddle::framework::proto::VarType* type);
  private:
  const ::paddle::framework::proto::VarType& _internal_type() const;
  ::paddle::framework::proto::VarType* _internal_mutable_type();
  public:
  void unsafe_arena_set_allocated_type(
      ::paddle::framework::proto::VarType* type);
  ::paddle::framework::proto::VarType* unsafe_arena_release_type();

  // optional bool persistable = 3 [default = false];
  bool has_persistable() const;
  private:
  bool _internal_has_persistable() const;
  public:
  void clear_persistable();
  bool persistable() const;
  void set_persistable(bool value);
  private:
  bool _internal_persistable() const;
  void _internal_set_persistable(bool value);
  public:

  // optional bool need_check_feed = 4 [default = false];
  bool has_need_check_feed() const;
  private:
  bool _internal_has_need_check_feed() const;
  public:
  void clear_need_check_feed();
  bool need_check_feed() const;
  void set_need_check_feed(bool value);
  private:
  bool _internal_need_check_feed() const;
  void _internal_set_need_check_feed(bool value);
  public:

  // optional bool is_parameter = 5 [default = false];
  bool has_is_parameter() const;
  private:
  bool _internal_has_is_parameter() const;
  public:
  void clear_is_parameter();
  bool is_parameter() const;
  void set_is_parameter(bool value);
  private:
  bool _internal_is_parameter() const;
  void _internal_set_is_parameter(bool value);
  public:

  // optional bool stop_gradient = 6 [default = false];
  bool has_stop_gradient() const;
  private:
  bool _internal_has_stop_gradient() const;
  public:
  void clear_stop_gradient();
  bool stop_gradient() const;
  void set_stop_gradient(bool value);
  private:
  bool _internal_stop_gradient() const;
  void _internal_set_stop_gradient(bool value);
  public:

  // @@protoc_insertion_point(class_scope:paddle.framework.proto.VarDesc)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::VarDesc_Attr > attrs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::paddle::framework::proto::VarType* type_;
    bool persistable_;
    bool need_check_feed_;
    bool is_parameter_;
    bool stop_gradient_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_paddle_2fphi_2fcore_2fframework_2fframework_2eproto;
};
// -------------------------------------------------------------------

class BlockDesc final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:paddle.framework.proto.BlockDesc) */ {
 public:
  inline BlockDesc() : BlockDesc(nullptr) {}
  ~BlockDesc() override;
  explicit PROTOBUF_CONSTEXPR BlockDesc(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockDesc(const BlockDesc& from);
  BlockDesc(BlockDesc&& from) noexcept
    : BlockDesc() {
    *this = ::std::move(from);
  }

  inline BlockDesc& operator=(const BlockDesc& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockDesc& operator=(BlockDesc&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockDesc& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockDesc* internal_default_instance() {
    return reinterpret_cast<const BlockDesc*>(
               &_BlockDesc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(BlockDesc& a, BlockDesc& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockDesc* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockDesc* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockDesc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockDesc>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockDesc& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockDesc& from) {
    BlockDesc::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockDesc* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "paddle.framework.proto.BlockDesc";
  }
  protected:
  explicit BlockDesc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVarsFieldNumber = 3,
    kOpsFieldNumber = 4,
    kIdxFieldNumber = 1,
    kParentIdxFieldNumber = 2,
    kForwardBlockIdxFieldNumber = 5,
  };
  // repeated .paddle.framework.proto.VarDesc vars = 3;
  int vars_size() const;
  private:
  int _internal_vars_size() const;
  public:
  void clear_vars();
  ::paddle::framework::proto::VarDesc* mutable_vars(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::VarDesc >*
      mutable_vars();
  private:
  const ::paddle::framework::proto::VarDesc& _internal_vars(int index) const;
  ::paddle::framework::proto::VarDesc* _internal_add_vars();
  public:
  const ::paddle::framework::proto::VarDesc& vars(int index) const;
  ::paddle::framework::proto::VarDesc* add_vars();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::VarDesc >&
      vars() const;

  // repeated .paddle.framework.proto.OpDesc ops = 4;
  int ops_size() const;
  private:
  int _internal_ops_size() const;
  public:
  void clear_ops();
  ::paddle::framework::proto::OpDesc* mutable_ops(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpDesc >*
      mutable_ops();
  private:
  const ::paddle::framework::proto::OpDesc& _internal_ops(int index) const;
  ::paddle::framework::proto::OpDesc* _internal_add_ops();
  public:
  const ::paddle::framework::proto::OpDesc& ops(int index) const;
  ::paddle::framework::proto::OpDesc* add_ops();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpDesc >&
      ops() const;

  // required int32 idx = 1;
  bool has_idx() const;
  private:
  bool _internal_has_idx() const;
  public:
  void clear_idx();
  int32_t idx() const;
  void set_idx(int32_t value);
  private:
  int32_t _internal_idx() const;
  void _internal_set_idx(int32_t value);
  public:

  // required int32 parent_idx = 2;
  bool has_parent_idx() const;
  private:
  bool _internal_has_parent_idx() const;
  public:
  void clear_parent_idx();
  int32_t parent_idx() const;
  void set_parent_idx(int32_t value);
  private:
  int32_t _internal_parent_idx() const;
  void _internal_set_parent_idx(int32_t value);
  public:

  // optional int32 forward_block_idx = 5 [default = -1];
  bool has_forward_block_idx() const;
  private:
  bool _internal_has_forward_block_idx() const;
  public:
  void clear_forward_block_idx();
  int32_t forward_block_idx() const;
  void set_forward_block_idx(int32_t value);
  private:
  int32_t _internal_forward_block_idx() const;
  void _internal_set_forward_block_idx(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:paddle.framework.proto.BlockDesc)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::VarDesc > vars_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpDesc > ops_;
    int32_t idx_;
    int32_t parent_idx_;
    int32_t forward_block_idx_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_paddle_2fphi_2fcore_2fframework_2fframework_2eproto;
};
// -------------------------------------------------------------------

class OpVersion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:paddle.framework.proto.OpVersion) */ {
 public:
  inline OpVersion() : OpVersion(nullptr) {}
  ~OpVersion() override;
  explicit PROTOBUF_CONSTEXPR OpVersion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpVersion(const OpVersion& from);
  OpVersion(OpVersion&& from) noexcept
    : OpVersion() {
    *this = ::std::move(from);
  }

  inline OpVersion& operator=(const OpVersion& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpVersion& operator=(OpVersion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpVersion& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpVersion* internal_default_instance() {
    return reinterpret_cast<const OpVersion*>(
               &_OpVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(OpVersion& a, OpVersion& b) {
    a.Swap(&b);
  }
  inline void Swap(OpVersion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpVersion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpVersion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpVersion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpVersion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpVersion& from) {
    OpVersion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpVersion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "paddle.framework.proto.OpVersion";
  }
  protected:
  explicit OpVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
  };
  // required int32 version = 1;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:paddle.framework.proto.OpVersion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t version_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_paddle_2fphi_2fcore_2fframework_2fframework_2eproto;
};
// -------------------------------------------------------------------

class OpVersionMap_OpVersionPair final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:paddle.framework.proto.OpVersionMap.OpVersionPair) */ {
 public:
  inline OpVersionMap_OpVersionPair() : OpVersionMap_OpVersionPair(nullptr) {}
  ~OpVersionMap_OpVersionPair() override;
  explicit PROTOBUF_CONSTEXPR OpVersionMap_OpVersionPair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpVersionMap_OpVersionPair(const OpVersionMap_OpVersionPair& from);
  OpVersionMap_OpVersionPair(OpVersionMap_OpVersionPair&& from) noexcept
    : OpVersionMap_OpVersionPair() {
    *this = ::std::move(from);
  }

  inline OpVersionMap_OpVersionPair& operator=(const OpVersionMap_OpVersionPair& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpVersionMap_OpVersionPair& operator=(OpVersionMap_OpVersionPair&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpVersionMap_OpVersionPair& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpVersionMap_OpVersionPair* internal_default_instance() {
    return reinterpret_cast<const OpVersionMap_OpVersionPair*>(
               &_OpVersionMap_OpVersionPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(OpVersionMap_OpVersionPair& a, OpVersionMap_OpVersionPair& b) {
    a.Swap(&b);
  }
  inline void Swap(OpVersionMap_OpVersionPair* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpVersionMap_OpVersionPair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpVersionMap_OpVersionPair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpVersionMap_OpVersionPair>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpVersionMap_OpVersionPair& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpVersionMap_OpVersionPair& from) {
    OpVersionMap_OpVersionPair::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpVersionMap_OpVersionPair* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "paddle.framework.proto.OpVersionMap.OpVersionPair";
  }
  protected:
  explicit OpVersionMap_OpVersionPair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpNameFieldNumber = 1,
    kOpVersionFieldNumber = 2,
  };
  // required string op_name = 1;
  bool has_op_name() const;
  private:
  bool _internal_has_op_name() const;
  public:
  void clear_op_name();
  const std::string& op_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_op_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_op_name();
  PROTOBUF_NODISCARD std::string* release_op_name();
  void set_allocated_op_name(std::string* op_name);
  private:
  const std::string& _internal_op_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_op_name(const std::string& value);
  std::string* _internal_mutable_op_name();
  public:

  // required .paddle.framework.proto.OpVersion op_version = 2;
  bool has_op_version() const;
  private:
  bool _internal_has_op_version() const;
  public:
  void clear_op_version();
  const ::paddle::framework::proto::OpVersion& op_version() const;
  PROTOBUF_NODISCARD ::paddle::framework::proto::OpVersion* release_op_version();
  ::paddle::framework::proto::OpVersion* mutable_op_version();
  void set_allocated_op_version(::paddle::framework::proto::OpVersion* op_version);
  private:
  const ::paddle::framework::proto::OpVersion& _internal_op_version() const;
  ::paddle::framework::proto::OpVersion* _internal_mutable_op_version();
  public:
  void unsafe_arena_set_allocated_op_version(
      ::paddle::framework::proto::OpVersion* op_version);
  ::paddle::framework::proto::OpVersion* unsafe_arena_release_op_version();

  // @@protoc_insertion_point(class_scope:paddle.framework.proto.OpVersionMap.OpVersionPair)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr op_name_;
    ::paddle::framework::proto::OpVersion* op_version_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_paddle_2fphi_2fcore_2fframework_2fframework_2eproto;
};
// -------------------------------------------------------------------

class OpVersionMap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:paddle.framework.proto.OpVersionMap) */ {
 public:
  inline OpVersionMap() : OpVersionMap(nullptr) {}
  ~OpVersionMap() override;
  explicit PROTOBUF_CONSTEXPR OpVersionMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpVersionMap(const OpVersionMap& from);
  OpVersionMap(OpVersionMap&& from) noexcept
    : OpVersionMap() {
    *this = ::std::move(from);
  }

  inline OpVersionMap& operator=(const OpVersionMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpVersionMap& operator=(OpVersionMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpVersionMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpVersionMap* internal_default_instance() {
    return reinterpret_cast<const OpVersionMap*>(
               &_OpVersionMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(OpVersionMap& a, OpVersionMap& b) {
    a.Swap(&b);
  }
  inline void Swap(OpVersionMap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpVersionMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpVersionMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpVersionMap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpVersionMap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpVersionMap& from) {
    OpVersionMap::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpVersionMap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "paddle.framework.proto.OpVersionMap";
  }
  protected:
  explicit OpVersionMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef OpVersionMap_OpVersionPair OpVersionPair;

  // accessors -------------------------------------------------------

  enum : int {
    kPairFieldNumber = 1,
  };
  // repeated .paddle.framework.proto.OpVersionMap.OpVersionPair pair = 1;
  int pair_size() const;
  private:
  int _internal_pair_size() const;
  public:
  void clear_pair();
  ::paddle::framework::proto::OpVersionMap_OpVersionPair* mutable_pair(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpVersionMap_OpVersionPair >*
      mutable_pair();
  private:
  const ::paddle::framework::proto::OpVersionMap_OpVersionPair& _internal_pair(int index) const;
  ::paddle::framework::proto::OpVersionMap_OpVersionPair* _internal_add_pair();
  public:
  const ::paddle::framework::proto::OpVersionMap_OpVersionPair& pair(int index) const;
  ::paddle::framework::proto::OpVersionMap_OpVersionPair* add_pair();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpVersionMap_OpVersionPair >&
      pair() const;

  // @@protoc_insertion_point(class_scope:paddle.framework.proto.OpVersionMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpVersionMap_OpVersionPair > pair_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_paddle_2fphi_2fcore_2fframework_2fframework_2eproto;
};
// -------------------------------------------------------------------

class ProgramDesc final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:paddle.framework.proto.ProgramDesc) */ {
 public:
  inline ProgramDesc() : ProgramDesc(nullptr) {}
  ~ProgramDesc() override;
  explicit PROTOBUF_CONSTEXPR ProgramDesc(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProgramDesc(const ProgramDesc& from);
  ProgramDesc(ProgramDesc&& from) noexcept
    : ProgramDesc() {
    *this = ::std::move(from);
  }

  inline ProgramDesc& operator=(const ProgramDesc& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProgramDesc& operator=(ProgramDesc&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProgramDesc& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProgramDesc* internal_default_instance() {
    return reinterpret_cast<const ProgramDesc*>(
               &_ProgramDesc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ProgramDesc& a, ProgramDesc& b) {
    a.Swap(&b);
  }
  inline void Swap(ProgramDesc* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProgramDesc* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProgramDesc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProgramDesc>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProgramDesc& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProgramDesc& from) {
    ProgramDesc::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProgramDesc* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "paddle.framework.proto.ProgramDesc";
  }
  protected:
  explicit ProgramDesc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlocksFieldNumber = 1,
    kVersionFieldNumber = 4,
    kOpVersionMapFieldNumber = 5,
  };
  // repeated .paddle.framework.proto.BlockDesc blocks = 1;
  int blocks_size() const;
  private:
  int _internal_blocks_size() const;
  public:
  void clear_blocks();
  ::paddle::framework::proto::BlockDesc* mutable_blocks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::BlockDesc >*
      mutable_blocks();
  private:
  const ::paddle::framework::proto::BlockDesc& _internal_blocks(int index) const;
  ::paddle::framework::proto::BlockDesc* _internal_add_blocks();
  public:
  const ::paddle::framework::proto::BlockDesc& blocks(int index) const;
  ::paddle::framework::proto::BlockDesc* add_blocks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::BlockDesc >&
      blocks() const;

  // optional .paddle.framework.proto.Version version = 4;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const ::paddle::framework::proto::Version& version() const;
  PROTOBUF_NODISCARD ::paddle::framework::proto::Version* release_version();
  ::paddle::framework::proto::Version* mutable_version();
  void set_allocated_version(::paddle::framework::proto::Version* version);
  private:
  const ::paddle::framework::proto::Version& _internal_version() const;
  ::paddle::framework::proto::Version* _internal_mutable_version();
  public:
  void unsafe_arena_set_allocated_version(
      ::paddle::framework::proto::Version* version);
  ::paddle::framework::proto::Version* unsafe_arena_release_version();

  // optional .paddle.framework.proto.OpVersionMap op_version_map = 5;
  bool has_op_version_map() const;
  private:
  bool _internal_has_op_version_map() const;
  public:
  void clear_op_version_map();
  const ::paddle::framework::proto::OpVersionMap& op_version_map() const;
  PROTOBUF_NODISCARD ::paddle::framework::proto::OpVersionMap* release_op_version_map();
  ::paddle::framework::proto::OpVersionMap* mutable_op_version_map();
  void set_allocated_op_version_map(::paddle::framework::proto::OpVersionMap* op_version_map);
  private:
  const ::paddle::framework::proto::OpVersionMap& _internal_op_version_map() const;
  ::paddle::framework::proto::OpVersionMap* _internal_mutable_op_version_map();
  public:
  void unsafe_arena_set_allocated_op_version_map(
      ::paddle::framework::proto::OpVersionMap* op_version_map);
  ::paddle::framework::proto::OpVersionMap* unsafe_arena_release_op_version_map();

  // @@protoc_insertion_point(class_scope:paddle.framework.proto.ProgramDesc)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::BlockDesc > blocks_;
    ::paddle::framework::proto::Version* version_;
    ::paddle::framework::proto::OpVersionMap* op_version_map_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_paddle_2fphi_2fcore_2fframework_2fframework_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Version

// optional int64 version = 1 [default = 0];
inline bool Version::_internal_has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Version::has_version() const {
  return _internal_has_version();
}
inline void Version::clear_version() {
  _impl_.version_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t Version::_internal_version() const {
  return _impl_.version_;
}
inline int64_t Version::version() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.Version.version)
  return _internal_version();
}
inline void Version::_internal_set_version(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.version_ = value;
}
inline void Version::set_version(int64_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.Version.version)
}

// -------------------------------------------------------------------

// Complex

// required double r = 1;
inline bool Complex::_internal_has_r() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Complex::has_r() const {
  return _internal_has_r();
}
inline void Complex::clear_r() {
  _impl_.r_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double Complex::_internal_r() const {
  return _impl_.r_;
}
inline double Complex::r() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.Complex.r)
  return _internal_r();
}
inline void Complex::_internal_set_r(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.r_ = value;
}
inline void Complex::set_r(double value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.Complex.r)
}

// required double i = 2;
inline bool Complex::_internal_has_i() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Complex::has_i() const {
  return _internal_has_i();
}
inline void Complex::clear_i() {
  _impl_.i_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double Complex::_internal_i() const {
  return _impl_.i_;
}
inline double Complex::i() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.Complex.i)
  return _internal_i();
}
inline void Complex::_internal_set_i(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.i_ = value;
}
inline void Complex::set_i(double value) {
  _internal_set_i(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.Complex.i)
}

// -------------------------------------------------------------------

// Scalar

// required .paddle.framework.proto.Scalar.Type type = 1;
inline bool Scalar::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Scalar::has_type() const {
  return _internal_has_type();
}
inline void Scalar::clear_type() {
  _impl_.type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::paddle::framework::proto::Scalar_Type Scalar::_internal_type() const {
  return static_cast< ::paddle::framework::proto::Scalar_Type >(_impl_.type_);
}
inline ::paddle::framework::proto::Scalar_Type Scalar::type() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.Scalar.type)
  return _internal_type();
}
inline void Scalar::_internal_set_type(::paddle::framework::proto::Scalar_Type value) {
  assert(::paddle::framework::proto::Scalar_Type_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.type_ = value;
}
inline void Scalar::set_type(::paddle::framework::proto::Scalar_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.Scalar.type)
}

// optional bool b = 2;
inline bool Scalar::_internal_has_b() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Scalar::has_b() const {
  return _internal_has_b();
}
inline void Scalar::clear_b() {
  _impl_.b_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool Scalar::_internal_b() const {
  return _impl_.b_;
}
inline bool Scalar::b() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.Scalar.b)
  return _internal_b();
}
inline void Scalar::_internal_set_b(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.b_ = value;
}
inline void Scalar::set_b(bool value) {
  _internal_set_b(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.Scalar.b)
}

// optional int64 i = 3;
inline bool Scalar::_internal_has_i() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Scalar::has_i() const {
  return _internal_has_i();
}
inline void Scalar::clear_i() {
  _impl_.i_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t Scalar::_internal_i() const {
  return _impl_.i_;
}
inline int64_t Scalar::i() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.Scalar.i)
  return _internal_i();
}
inline void Scalar::_internal_set_i(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.i_ = value;
}
inline void Scalar::set_i(int64_t value) {
  _internal_set_i(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.Scalar.i)
}

// optional double r = 4;
inline bool Scalar::_internal_has_r() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Scalar::has_r() const {
  return _internal_has_r();
}
inline void Scalar::clear_r() {
  _impl_.r_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double Scalar::_internal_r() const {
  return _impl_.r_;
}
inline double Scalar::r() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.Scalar.r)
  return _internal_r();
}
inline void Scalar::_internal_set_r(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.r_ = value;
}
inline void Scalar::set_r(double value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.Scalar.r)
}

// optional .paddle.framework.proto.Complex c = 5;
inline bool Scalar::_internal_has_c() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.c_ != nullptr);
  return value;
}
inline bool Scalar::has_c() const {
  return _internal_has_c();
}
inline void Scalar::clear_c() {
  if (_impl_.c_ != nullptr) _impl_.c_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::paddle::framework::proto::Complex& Scalar::_internal_c() const {
  const ::paddle::framework::proto::Complex* p = _impl_.c_;
  return p != nullptr ? *p : reinterpret_cast<const ::paddle::framework::proto::Complex&>(
      ::paddle::framework::proto::_Complex_default_instance_);
}
inline const ::paddle::framework::proto::Complex& Scalar::c() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.Scalar.c)
  return _internal_c();
}
inline void Scalar::unsafe_arena_set_allocated_c(
    ::paddle::framework::proto::Complex* c) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.c_);
  }
  _impl_.c_ = c;
  if (c) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:paddle.framework.proto.Scalar.c)
}
inline ::paddle::framework::proto::Complex* Scalar::release_c() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::paddle::framework::proto::Complex* temp = _impl_.c_;
  _impl_.c_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::paddle::framework::proto::Complex* Scalar::unsafe_arena_release_c() {
  // @@protoc_insertion_point(field_release:paddle.framework.proto.Scalar.c)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::paddle::framework::proto::Complex* temp = _impl_.c_;
  _impl_.c_ = nullptr;
  return temp;
}
inline ::paddle::framework::proto::Complex* Scalar::_internal_mutable_c() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.c_ == nullptr) {
    auto* p = CreateMaybeMessage<::paddle::framework::proto::Complex>(GetArenaForAllocation());
    _impl_.c_ = p;
  }
  return _impl_.c_;
}
inline ::paddle::framework::proto::Complex* Scalar::mutable_c() {
  ::paddle::framework::proto::Complex* _msg = _internal_mutable_c();
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.Scalar.c)
  return _msg;
}
inline void Scalar::set_allocated_c(::paddle::framework::proto::Complex* c) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.c_;
  }
  if (c) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(c);
    if (message_arena != submessage_arena) {
      c = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, c, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.c_ = c;
  // @@protoc_insertion_point(field_set_allocated:paddle.framework.proto.Scalar.c)
}

// -------------------------------------------------------------------

// OpDesc_Attr

// required string name = 1;
inline bool OpDesc_Attr::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OpDesc_Attr::has_name() const {
  return _internal_has_name();
}
inline void OpDesc_Attr::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OpDesc_Attr::name() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpDesc.Attr.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpDesc_Attr::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpDesc.Attr.name)
}
inline std::string* OpDesc_Attr::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.OpDesc.Attr.name)
  return _s;
}
inline const std::string& OpDesc_Attr::_internal_name() const {
  return _impl_.name_.Get();
}
inline void OpDesc_Attr::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* OpDesc_Attr::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* OpDesc_Attr::release_name() {
  // @@protoc_insertion_point(field_release:paddle.framework.proto.OpDesc.Attr.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OpDesc_Attr::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:paddle.framework.proto.OpDesc.Attr.name)
}

// required .paddle.framework.proto.AttrType type = 2;
inline bool OpDesc_Attr::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool OpDesc_Attr::has_type() const {
  return _internal_has_type();
}
inline void OpDesc_Attr::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::paddle::framework::proto::AttrType OpDesc_Attr::_internal_type() const {
  return static_cast< ::paddle::framework::proto::AttrType >(_impl_.type_);
}
inline ::paddle::framework::proto::AttrType OpDesc_Attr::type() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpDesc.Attr.type)
  return _internal_type();
}
inline void OpDesc_Attr::_internal_set_type(::paddle::framework::proto::AttrType value) {
  assert(::paddle::framework::proto::AttrType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.type_ = value;
}
inline void OpDesc_Attr::set_type(::paddle::framework::proto::AttrType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpDesc.Attr.type)
}

// optional int32 i = 3;
inline bool OpDesc_Attr::_internal_has_i() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool OpDesc_Attr::has_i() const {
  return _internal_has_i();
}
inline void OpDesc_Attr::clear_i() {
  _impl_.i_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t OpDesc_Attr::_internal_i() const {
  return _impl_.i_;
}
inline int32_t OpDesc_Attr::i() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpDesc.Attr.i)
  return _internal_i();
}
inline void OpDesc_Attr::_internal_set_i(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.i_ = value;
}
inline void OpDesc_Attr::set_i(int32_t value) {
  _internal_set_i(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpDesc.Attr.i)
}

// optional float f = 4;
inline bool OpDesc_Attr::_internal_has_f() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool OpDesc_Attr::has_f() const {
  return _internal_has_f();
}
inline void OpDesc_Attr::clear_f() {
  _impl_.f_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float OpDesc_Attr::_internal_f() const {
  return _impl_.f_;
}
inline float OpDesc_Attr::f() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpDesc.Attr.f)
  return _internal_f();
}
inline void OpDesc_Attr::_internal_set_f(float value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.f_ = value;
}
inline void OpDesc_Attr::set_f(float value) {
  _internal_set_f(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpDesc.Attr.f)
}

// optional string s = 5;
inline bool OpDesc_Attr::_internal_has_s() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OpDesc_Attr::has_s() const {
  return _internal_has_s();
}
inline void OpDesc_Attr::clear_s() {
  _impl_.s_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& OpDesc_Attr::s() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpDesc.Attr.s)
  return _internal_s();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpDesc_Attr::set_s(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.s_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpDesc.Attr.s)
}
inline std::string* OpDesc_Attr::mutable_s() {
  std::string* _s = _internal_mutable_s();
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.OpDesc.Attr.s)
  return _s;
}
inline const std::string& OpDesc_Attr::_internal_s() const {
  return _impl_.s_.Get();
}
inline void OpDesc_Attr::_internal_set_s(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.s_.Set(value, GetArenaForAllocation());
}
inline std::string* OpDesc_Attr::_internal_mutable_s() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.s_.Mutable(GetArenaForAllocation());
}
inline std::string* OpDesc_Attr::release_s() {
  // @@protoc_insertion_point(field_release:paddle.framework.proto.OpDesc.Attr.s)
  if (!_internal_has_s()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.s_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.s_.IsDefault()) {
    _impl_.s_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OpDesc_Attr::set_allocated_s(std::string* s) {
  if (s != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.s_.SetAllocated(s, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.s_.IsDefault()) {
    _impl_.s_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:paddle.framework.proto.OpDesc.Attr.s)
}

// repeated int32 ints = 6;
inline int OpDesc_Attr::_internal_ints_size() const {
  return _impl_.ints_.size();
}
inline int OpDesc_Attr::ints_size() const {
  return _internal_ints_size();
}
inline void OpDesc_Attr::clear_ints() {
  _impl_.ints_.Clear();
}
inline int32_t OpDesc_Attr::_internal_ints(int index) const {
  return _impl_.ints_.Get(index);
}
inline int32_t OpDesc_Attr::ints(int index) const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpDesc.Attr.ints)
  return _internal_ints(index);
}
inline void OpDesc_Attr::set_ints(int index, int32_t value) {
  _impl_.ints_.Set(index, value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpDesc.Attr.ints)
}
inline void OpDesc_Attr::_internal_add_ints(int32_t value) {
  _impl_.ints_.Add(value);
}
inline void OpDesc_Attr::add_ints(int32_t value) {
  _internal_add_ints(value);
  // @@protoc_insertion_point(field_add:paddle.framework.proto.OpDesc.Attr.ints)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
OpDesc_Attr::_internal_ints() const {
  return _impl_.ints_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
OpDesc_Attr::ints() const {
  // @@protoc_insertion_point(field_list:paddle.framework.proto.OpDesc.Attr.ints)
  return _internal_ints();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
OpDesc_Attr::_internal_mutable_ints() {
  return &_impl_.ints_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
OpDesc_Attr::mutable_ints() {
  // @@protoc_insertion_point(field_mutable_list:paddle.framework.proto.OpDesc.Attr.ints)
  return _internal_mutable_ints();
}

// repeated float floats = 7;
inline int OpDesc_Attr::_internal_floats_size() const {
  return _impl_.floats_.size();
}
inline int OpDesc_Attr::floats_size() const {
  return _internal_floats_size();
}
inline void OpDesc_Attr::clear_floats() {
  _impl_.floats_.Clear();
}
inline float OpDesc_Attr::_internal_floats(int index) const {
  return _impl_.floats_.Get(index);
}
inline float OpDesc_Attr::floats(int index) const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpDesc.Attr.floats)
  return _internal_floats(index);
}
inline void OpDesc_Attr::set_floats(int index, float value) {
  _impl_.floats_.Set(index, value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpDesc.Attr.floats)
}
inline void OpDesc_Attr::_internal_add_floats(float value) {
  _impl_.floats_.Add(value);
}
inline void OpDesc_Attr::add_floats(float value) {
  _internal_add_floats(value);
  // @@protoc_insertion_point(field_add:paddle.framework.proto.OpDesc.Attr.floats)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
OpDesc_Attr::_internal_floats() const {
  return _impl_.floats_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
OpDesc_Attr::floats() const {
  // @@protoc_insertion_point(field_list:paddle.framework.proto.OpDesc.Attr.floats)
  return _internal_floats();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
OpDesc_Attr::_internal_mutable_floats() {
  return &_impl_.floats_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
OpDesc_Attr::mutable_floats() {
  // @@protoc_insertion_point(field_mutable_list:paddle.framework.proto.OpDesc.Attr.floats)
  return _internal_mutable_floats();
}

// repeated string strings = 8;
inline int OpDesc_Attr::_internal_strings_size() const {
  return _impl_.strings_.size();
}
inline int OpDesc_Attr::strings_size() const {
  return _internal_strings_size();
}
inline void OpDesc_Attr::clear_strings() {
  _impl_.strings_.Clear();
}
inline std::string* OpDesc_Attr::add_strings() {
  std::string* _s = _internal_add_strings();
  // @@protoc_insertion_point(field_add_mutable:paddle.framework.proto.OpDesc.Attr.strings)
  return _s;
}
inline const std::string& OpDesc_Attr::_internal_strings(int index) const {
  return _impl_.strings_.Get(index);
}
inline const std::string& OpDesc_Attr::strings(int index) const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpDesc.Attr.strings)
  return _internal_strings(index);
}
inline std::string* OpDesc_Attr::mutable_strings(int index) {
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.OpDesc.Attr.strings)
  return _impl_.strings_.Mutable(index);
}
inline void OpDesc_Attr::set_strings(int index, const std::string& value) {
  _impl_.strings_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpDesc.Attr.strings)
}
inline void OpDesc_Attr::set_strings(int index, std::string&& value) {
  _impl_.strings_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpDesc.Attr.strings)
}
inline void OpDesc_Attr::set_strings(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.strings_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:paddle.framework.proto.OpDesc.Attr.strings)
}
inline void OpDesc_Attr::set_strings(int index, const char* value, size_t size) {
  _impl_.strings_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:paddle.framework.proto.OpDesc.Attr.strings)
}
inline std::string* OpDesc_Attr::_internal_add_strings() {
  return _impl_.strings_.Add();
}
inline void OpDesc_Attr::add_strings(const std::string& value) {
  _impl_.strings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:paddle.framework.proto.OpDesc.Attr.strings)
}
inline void OpDesc_Attr::add_strings(std::string&& value) {
  _impl_.strings_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:paddle.framework.proto.OpDesc.Attr.strings)
}
inline void OpDesc_Attr::add_strings(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.strings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:paddle.framework.proto.OpDesc.Attr.strings)
}
inline void OpDesc_Attr::add_strings(const char* value, size_t size) {
  _impl_.strings_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:paddle.framework.proto.OpDesc.Attr.strings)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OpDesc_Attr::strings() const {
  // @@protoc_insertion_point(field_list:paddle.framework.proto.OpDesc.Attr.strings)
  return _impl_.strings_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OpDesc_Attr::mutable_strings() {
  // @@protoc_insertion_point(field_mutable_list:paddle.framework.proto.OpDesc.Attr.strings)
  return &_impl_.strings_;
}

// optional bool b = 10;
inline bool OpDesc_Attr::_internal_has_b() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool OpDesc_Attr::has_b() const {
  return _internal_has_b();
}
inline void OpDesc_Attr::clear_b() {
  _impl_.b_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool OpDesc_Attr::_internal_b() const {
  return _impl_.b_;
}
inline bool OpDesc_Attr::b() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpDesc.Attr.b)
  return _internal_b();
}
inline void OpDesc_Attr::_internal_set_b(bool value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.b_ = value;
}
inline void OpDesc_Attr::set_b(bool value) {
  _internal_set_b(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpDesc.Attr.b)
}

// repeated bool bools = 11;
inline int OpDesc_Attr::_internal_bools_size() const {
  return _impl_.bools_.size();
}
inline int OpDesc_Attr::bools_size() const {
  return _internal_bools_size();
}
inline void OpDesc_Attr::clear_bools() {
  _impl_.bools_.Clear();
}
inline bool OpDesc_Attr::_internal_bools(int index) const {
  return _impl_.bools_.Get(index);
}
inline bool OpDesc_Attr::bools(int index) const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpDesc.Attr.bools)
  return _internal_bools(index);
}
inline void OpDesc_Attr::set_bools(int index, bool value) {
  _impl_.bools_.Set(index, value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpDesc.Attr.bools)
}
inline void OpDesc_Attr::_internal_add_bools(bool value) {
  _impl_.bools_.Add(value);
}
inline void OpDesc_Attr::add_bools(bool value) {
  _internal_add_bools(value);
  // @@protoc_insertion_point(field_add:paddle.framework.proto.OpDesc.Attr.bools)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
OpDesc_Attr::_internal_bools() const {
  return _impl_.bools_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
OpDesc_Attr::bools() const {
  // @@protoc_insertion_point(field_list:paddle.framework.proto.OpDesc.Attr.bools)
  return _internal_bools();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
OpDesc_Attr::_internal_mutable_bools() {
  return &_impl_.bools_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
OpDesc_Attr::mutable_bools() {
  // @@protoc_insertion_point(field_mutable_list:paddle.framework.proto.OpDesc.Attr.bools)
  return _internal_mutable_bools();
}

// optional int32 block_idx = 12;
inline bool OpDesc_Attr::_internal_has_block_idx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool OpDesc_Attr::has_block_idx() const {
  return _internal_has_block_idx();
}
inline void OpDesc_Attr::clear_block_idx() {
  _impl_.block_idx_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline int32_t OpDesc_Attr::_internal_block_idx() const {
  return _impl_.block_idx_;
}
inline int32_t OpDesc_Attr::block_idx() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpDesc.Attr.block_idx)
  return _internal_block_idx();
}
inline void OpDesc_Attr::_internal_set_block_idx(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.block_idx_ = value;
}
inline void OpDesc_Attr::set_block_idx(int32_t value) {
  _internal_set_block_idx(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpDesc.Attr.block_idx)
}

// optional int64 l = 13;
inline bool OpDesc_Attr::_internal_has_l() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool OpDesc_Attr::has_l() const {
  return _internal_has_l();
}
inline void OpDesc_Attr::clear_l() {
  _impl_.l_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int64_t OpDesc_Attr::_internal_l() const {
  return _impl_.l_;
}
inline int64_t OpDesc_Attr::l() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpDesc.Attr.l)
  return _internal_l();
}
inline void OpDesc_Attr::_internal_set_l(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.l_ = value;
}
inline void OpDesc_Attr::set_l(int64_t value) {
  _internal_set_l(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpDesc.Attr.l)
}

// repeated int32 blocks_idx = 14;
inline int OpDesc_Attr::_internal_blocks_idx_size() const {
  return _impl_.blocks_idx_.size();
}
inline int OpDesc_Attr::blocks_idx_size() const {
  return _internal_blocks_idx_size();
}
inline void OpDesc_Attr::clear_blocks_idx() {
  _impl_.blocks_idx_.Clear();
}
inline int32_t OpDesc_Attr::_internal_blocks_idx(int index) const {
  return _impl_.blocks_idx_.Get(index);
}
inline int32_t OpDesc_Attr::blocks_idx(int index) const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpDesc.Attr.blocks_idx)
  return _internal_blocks_idx(index);
}
inline void OpDesc_Attr::set_blocks_idx(int index, int32_t value) {
  _impl_.blocks_idx_.Set(index, value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpDesc.Attr.blocks_idx)
}
inline void OpDesc_Attr::_internal_add_blocks_idx(int32_t value) {
  _impl_.blocks_idx_.Add(value);
}
inline void OpDesc_Attr::add_blocks_idx(int32_t value) {
  _internal_add_blocks_idx(value);
  // @@protoc_insertion_point(field_add:paddle.framework.proto.OpDesc.Attr.blocks_idx)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
OpDesc_Attr::_internal_blocks_idx() const {
  return _impl_.blocks_idx_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
OpDesc_Attr::blocks_idx() const {
  // @@protoc_insertion_point(field_list:paddle.framework.proto.OpDesc.Attr.blocks_idx)
  return _internal_blocks_idx();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
OpDesc_Attr::_internal_mutable_blocks_idx() {
  return &_impl_.blocks_idx_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
OpDesc_Attr::mutable_blocks_idx() {
  // @@protoc_insertion_point(field_mutable_list:paddle.framework.proto.OpDesc.Attr.blocks_idx)
  return _internal_mutable_blocks_idx();
}

// repeated int64 longs = 15;
inline int OpDesc_Attr::_internal_longs_size() const {
  return _impl_.longs_.size();
}
inline int OpDesc_Attr::longs_size() const {
  return _internal_longs_size();
}
inline void OpDesc_Attr::clear_longs() {
  _impl_.longs_.Clear();
}
inline int64_t OpDesc_Attr::_internal_longs(int index) const {
  return _impl_.longs_.Get(index);
}
inline int64_t OpDesc_Attr::longs(int index) const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpDesc.Attr.longs)
  return _internal_longs(index);
}
inline void OpDesc_Attr::set_longs(int index, int64_t value) {
  _impl_.longs_.Set(index, value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpDesc.Attr.longs)
}
inline void OpDesc_Attr::_internal_add_longs(int64_t value) {
  _impl_.longs_.Add(value);
}
inline void OpDesc_Attr::add_longs(int64_t value) {
  _internal_add_longs(value);
  // @@protoc_insertion_point(field_add:paddle.framework.proto.OpDesc.Attr.longs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
OpDesc_Attr::_internal_longs() const {
  return _impl_.longs_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
OpDesc_Attr::longs() const {
  // @@protoc_insertion_point(field_list:paddle.framework.proto.OpDesc.Attr.longs)
  return _internal_longs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
OpDesc_Attr::_internal_mutable_longs() {
  return &_impl_.longs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
OpDesc_Attr::mutable_longs() {
  // @@protoc_insertion_point(field_mutable_list:paddle.framework.proto.OpDesc.Attr.longs)
  return _internal_mutable_longs();
}

// repeated double float64s = 16;
inline int OpDesc_Attr::_internal_float64s_size() const {
  return _impl_.float64s_.size();
}
inline int OpDesc_Attr::float64s_size() const {
  return _internal_float64s_size();
}
inline void OpDesc_Attr::clear_float64s() {
  _impl_.float64s_.Clear();
}
inline double OpDesc_Attr::_internal_float64s(int index) const {
  return _impl_.float64s_.Get(index);
}
inline double OpDesc_Attr::float64s(int index) const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpDesc.Attr.float64s)
  return _internal_float64s(index);
}
inline void OpDesc_Attr::set_float64s(int index, double value) {
  _impl_.float64s_.Set(index, value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpDesc.Attr.float64s)
}
inline void OpDesc_Attr::_internal_add_float64s(double value) {
  _impl_.float64s_.Add(value);
}
inline void OpDesc_Attr::add_float64s(double value) {
  _internal_add_float64s(value);
  // @@protoc_insertion_point(field_add:paddle.framework.proto.OpDesc.Attr.float64s)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
OpDesc_Attr::_internal_float64s() const {
  return _impl_.float64s_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
OpDesc_Attr::float64s() const {
  // @@protoc_insertion_point(field_list:paddle.framework.proto.OpDesc.Attr.float64s)
  return _internal_float64s();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
OpDesc_Attr::_internal_mutable_float64s() {
  return &_impl_.float64s_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
OpDesc_Attr::mutable_float64s() {
  // @@protoc_insertion_point(field_mutable_list:paddle.framework.proto.OpDesc.Attr.float64s)
  return _internal_mutable_float64s();
}

// optional string var_name = 17;
inline bool OpDesc_Attr::_internal_has_var_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool OpDesc_Attr::has_var_name() const {
  return _internal_has_var_name();
}
inline void OpDesc_Attr::clear_var_name() {
  _impl_.var_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& OpDesc_Attr::var_name() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpDesc.Attr.var_name)
  return _internal_var_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpDesc_Attr::set_var_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.var_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpDesc.Attr.var_name)
}
inline std::string* OpDesc_Attr::mutable_var_name() {
  std::string* _s = _internal_mutable_var_name();
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.OpDesc.Attr.var_name)
  return _s;
}
inline const std::string& OpDesc_Attr::_internal_var_name() const {
  return _impl_.var_name_.Get();
}
inline void OpDesc_Attr::_internal_set_var_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.var_name_.Set(value, GetArenaForAllocation());
}
inline std::string* OpDesc_Attr::_internal_mutable_var_name() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.var_name_.Mutable(GetArenaForAllocation());
}
inline std::string* OpDesc_Attr::release_var_name() {
  // @@protoc_insertion_point(field_release:paddle.framework.proto.OpDesc.Attr.var_name)
  if (!_internal_has_var_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.var_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.var_name_.IsDefault()) {
    _impl_.var_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OpDesc_Attr::set_allocated_var_name(std::string* var_name) {
  if (var_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.var_name_.SetAllocated(var_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.var_name_.IsDefault()) {
    _impl_.var_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:paddle.framework.proto.OpDesc.Attr.var_name)
}

// repeated string vars_name = 18;
inline int OpDesc_Attr::_internal_vars_name_size() const {
  return _impl_.vars_name_.size();
}
inline int OpDesc_Attr::vars_name_size() const {
  return _internal_vars_name_size();
}
inline void OpDesc_Attr::clear_vars_name() {
  _impl_.vars_name_.Clear();
}
inline std::string* OpDesc_Attr::add_vars_name() {
  std::string* _s = _internal_add_vars_name();
  // @@protoc_insertion_point(field_add_mutable:paddle.framework.proto.OpDesc.Attr.vars_name)
  return _s;
}
inline const std::string& OpDesc_Attr::_internal_vars_name(int index) const {
  return _impl_.vars_name_.Get(index);
}
inline const std::string& OpDesc_Attr::vars_name(int index) const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpDesc.Attr.vars_name)
  return _internal_vars_name(index);
}
inline std::string* OpDesc_Attr::mutable_vars_name(int index) {
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.OpDesc.Attr.vars_name)
  return _impl_.vars_name_.Mutable(index);
}
inline void OpDesc_Attr::set_vars_name(int index, const std::string& value) {
  _impl_.vars_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpDesc.Attr.vars_name)
}
inline void OpDesc_Attr::set_vars_name(int index, std::string&& value) {
  _impl_.vars_name_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpDesc.Attr.vars_name)
}
inline void OpDesc_Attr::set_vars_name(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.vars_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:paddle.framework.proto.OpDesc.Attr.vars_name)
}
inline void OpDesc_Attr::set_vars_name(int index, const char* value, size_t size) {
  _impl_.vars_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:paddle.framework.proto.OpDesc.Attr.vars_name)
}
inline std::string* OpDesc_Attr::_internal_add_vars_name() {
  return _impl_.vars_name_.Add();
}
inline void OpDesc_Attr::add_vars_name(const std::string& value) {
  _impl_.vars_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:paddle.framework.proto.OpDesc.Attr.vars_name)
}
inline void OpDesc_Attr::add_vars_name(std::string&& value) {
  _impl_.vars_name_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:paddle.framework.proto.OpDesc.Attr.vars_name)
}
inline void OpDesc_Attr::add_vars_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.vars_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:paddle.framework.proto.OpDesc.Attr.vars_name)
}
inline void OpDesc_Attr::add_vars_name(const char* value, size_t size) {
  _impl_.vars_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:paddle.framework.proto.OpDesc.Attr.vars_name)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OpDesc_Attr::vars_name() const {
  // @@protoc_insertion_point(field_list:paddle.framework.proto.OpDesc.Attr.vars_name)
  return _impl_.vars_name_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OpDesc_Attr::mutable_vars_name() {
  // @@protoc_insertion_point(field_mutable_list:paddle.framework.proto.OpDesc.Attr.vars_name)
  return &_impl_.vars_name_;
}

// optional double float64 = 19;
inline bool OpDesc_Attr::_internal_has_float64() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool OpDesc_Attr::has_float64() const {
  return _internal_has_float64();
}
inline void OpDesc_Attr::clear_float64() {
  _impl_.float64_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline double OpDesc_Attr::_internal_float64() const {
  return _impl_.float64_;
}
inline double OpDesc_Attr::float64() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpDesc.Attr.float64)
  return _internal_float64();
}
inline void OpDesc_Attr::_internal_set_float64(double value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.float64_ = value;
}
inline void OpDesc_Attr::set_float64(double value) {
  _internal_set_float64(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpDesc.Attr.float64)
}

// optional .paddle.framework.proto.Scalar scalar = 20;
inline bool OpDesc_Attr::_internal_has_scalar() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.scalar_ != nullptr);
  return value;
}
inline bool OpDesc_Attr::has_scalar() const {
  return _internal_has_scalar();
}
inline void OpDesc_Attr::clear_scalar() {
  if (_impl_.scalar_ != nullptr) _impl_.scalar_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::paddle::framework::proto::Scalar& OpDesc_Attr::_internal_scalar() const {
  const ::paddle::framework::proto::Scalar* p = _impl_.scalar_;
  return p != nullptr ? *p : reinterpret_cast<const ::paddle::framework::proto::Scalar&>(
      ::paddle::framework::proto::_Scalar_default_instance_);
}
inline const ::paddle::framework::proto::Scalar& OpDesc_Attr::scalar() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpDesc.Attr.scalar)
  return _internal_scalar();
}
inline void OpDesc_Attr::unsafe_arena_set_allocated_scalar(
    ::paddle::framework::proto::Scalar* scalar) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.scalar_);
  }
  _impl_.scalar_ = scalar;
  if (scalar) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:paddle.framework.proto.OpDesc.Attr.scalar)
}
inline ::paddle::framework::proto::Scalar* OpDesc_Attr::release_scalar() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::paddle::framework::proto::Scalar* temp = _impl_.scalar_;
  _impl_.scalar_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::paddle::framework::proto::Scalar* OpDesc_Attr::unsafe_arena_release_scalar() {
  // @@protoc_insertion_point(field_release:paddle.framework.proto.OpDesc.Attr.scalar)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::paddle::framework::proto::Scalar* temp = _impl_.scalar_;
  _impl_.scalar_ = nullptr;
  return temp;
}
inline ::paddle::framework::proto::Scalar* OpDesc_Attr::_internal_mutable_scalar() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.scalar_ == nullptr) {
    auto* p = CreateMaybeMessage<::paddle::framework::proto::Scalar>(GetArenaForAllocation());
    _impl_.scalar_ = p;
  }
  return _impl_.scalar_;
}
inline ::paddle::framework::proto::Scalar* OpDesc_Attr::mutable_scalar() {
  ::paddle::framework::proto::Scalar* _msg = _internal_mutable_scalar();
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.OpDesc.Attr.scalar)
  return _msg;
}
inline void OpDesc_Attr::set_allocated_scalar(::paddle::framework::proto::Scalar* scalar) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.scalar_;
  }
  if (scalar) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(scalar);
    if (message_arena != submessage_arena) {
      scalar = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scalar, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.scalar_ = scalar;
  // @@protoc_insertion_point(field_set_allocated:paddle.framework.proto.OpDesc.Attr.scalar)
}

// repeated .paddle.framework.proto.Scalar scalars = 21;
inline int OpDesc_Attr::_internal_scalars_size() const {
  return _impl_.scalars_.size();
}
inline int OpDesc_Attr::scalars_size() const {
  return _internal_scalars_size();
}
inline void OpDesc_Attr::clear_scalars() {
  _impl_.scalars_.Clear();
}
inline ::paddle::framework::proto::Scalar* OpDesc_Attr::mutable_scalars(int index) {
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.OpDesc.Attr.scalars)
  return _impl_.scalars_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::Scalar >*
OpDesc_Attr::mutable_scalars() {
  // @@protoc_insertion_point(field_mutable_list:paddle.framework.proto.OpDesc.Attr.scalars)
  return &_impl_.scalars_;
}
inline const ::paddle::framework::proto::Scalar& OpDesc_Attr::_internal_scalars(int index) const {
  return _impl_.scalars_.Get(index);
}
inline const ::paddle::framework::proto::Scalar& OpDesc_Attr::scalars(int index) const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpDesc.Attr.scalars)
  return _internal_scalars(index);
}
inline ::paddle::framework::proto::Scalar* OpDesc_Attr::_internal_add_scalars() {
  return _impl_.scalars_.Add();
}
inline ::paddle::framework::proto::Scalar* OpDesc_Attr::add_scalars() {
  ::paddle::framework::proto::Scalar* _add = _internal_add_scalars();
  // @@protoc_insertion_point(field_add:paddle.framework.proto.OpDesc.Attr.scalars)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::Scalar >&
OpDesc_Attr::scalars() const {
  // @@protoc_insertion_point(field_list:paddle.framework.proto.OpDesc.Attr.scalars)
  return _impl_.scalars_;
}

// -------------------------------------------------------------------

// OpDesc_Var

// required string parameter = 1;
inline bool OpDesc_Var::_internal_has_parameter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OpDesc_Var::has_parameter() const {
  return _internal_has_parameter();
}
inline void OpDesc_Var::clear_parameter() {
  _impl_.parameter_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OpDesc_Var::parameter() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpDesc.Var.parameter)
  return _internal_parameter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpDesc_Var::set_parameter(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.parameter_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpDesc.Var.parameter)
}
inline std::string* OpDesc_Var::mutable_parameter() {
  std::string* _s = _internal_mutable_parameter();
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.OpDesc.Var.parameter)
  return _s;
}
inline const std::string& OpDesc_Var::_internal_parameter() const {
  return _impl_.parameter_.Get();
}
inline void OpDesc_Var::_internal_set_parameter(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.parameter_.Set(value, GetArenaForAllocation());
}
inline std::string* OpDesc_Var::_internal_mutable_parameter() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.parameter_.Mutable(GetArenaForAllocation());
}
inline std::string* OpDesc_Var::release_parameter() {
  // @@protoc_insertion_point(field_release:paddle.framework.proto.OpDesc.Var.parameter)
  if (!_internal_has_parameter()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.parameter_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parameter_.IsDefault()) {
    _impl_.parameter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OpDesc_Var::set_allocated_parameter(std::string* parameter) {
  if (parameter != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.parameter_.SetAllocated(parameter, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parameter_.IsDefault()) {
    _impl_.parameter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:paddle.framework.proto.OpDesc.Var.parameter)
}

// repeated string arguments = 2;
inline int OpDesc_Var::_internal_arguments_size() const {
  return _impl_.arguments_.size();
}
inline int OpDesc_Var::arguments_size() const {
  return _internal_arguments_size();
}
inline void OpDesc_Var::clear_arguments() {
  _impl_.arguments_.Clear();
}
inline std::string* OpDesc_Var::add_arguments() {
  std::string* _s = _internal_add_arguments();
  // @@protoc_insertion_point(field_add_mutable:paddle.framework.proto.OpDesc.Var.arguments)
  return _s;
}
inline const std::string& OpDesc_Var::_internal_arguments(int index) const {
  return _impl_.arguments_.Get(index);
}
inline const std::string& OpDesc_Var::arguments(int index) const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpDesc.Var.arguments)
  return _internal_arguments(index);
}
inline std::string* OpDesc_Var::mutable_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.OpDesc.Var.arguments)
  return _impl_.arguments_.Mutable(index);
}
inline void OpDesc_Var::set_arguments(int index, const std::string& value) {
  _impl_.arguments_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpDesc.Var.arguments)
}
inline void OpDesc_Var::set_arguments(int index, std::string&& value) {
  _impl_.arguments_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpDesc.Var.arguments)
}
inline void OpDesc_Var::set_arguments(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.arguments_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:paddle.framework.proto.OpDesc.Var.arguments)
}
inline void OpDesc_Var::set_arguments(int index, const char* value, size_t size) {
  _impl_.arguments_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:paddle.framework.proto.OpDesc.Var.arguments)
}
inline std::string* OpDesc_Var::_internal_add_arguments() {
  return _impl_.arguments_.Add();
}
inline void OpDesc_Var::add_arguments(const std::string& value) {
  _impl_.arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:paddle.framework.proto.OpDesc.Var.arguments)
}
inline void OpDesc_Var::add_arguments(std::string&& value) {
  _impl_.arguments_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:paddle.framework.proto.OpDesc.Var.arguments)
}
inline void OpDesc_Var::add_arguments(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:paddle.framework.proto.OpDesc.Var.arguments)
}
inline void OpDesc_Var::add_arguments(const char* value, size_t size) {
  _impl_.arguments_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:paddle.framework.proto.OpDesc.Var.arguments)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OpDesc_Var::arguments() const {
  // @@protoc_insertion_point(field_list:paddle.framework.proto.OpDesc.Var.arguments)
  return _impl_.arguments_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OpDesc_Var::mutable_arguments() {
  // @@protoc_insertion_point(field_mutable_list:paddle.framework.proto.OpDesc.Var.arguments)
  return &_impl_.arguments_;
}

// -------------------------------------------------------------------

// OpDesc

// required string type = 3;
inline bool OpDesc::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OpDesc::has_type() const {
  return _internal_has_type();
}
inline void OpDesc::clear_type() {
  _impl_.type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OpDesc::type() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpDesc.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpDesc::set_type(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpDesc.type)
}
inline std::string* OpDesc::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.OpDesc.type)
  return _s;
}
inline const std::string& OpDesc::_internal_type() const {
  return _impl_.type_.Get();
}
inline void OpDesc::_internal_set_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* OpDesc::_internal_mutable_type() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* OpDesc::release_type() {
  // @@protoc_insertion_point(field_release:paddle.framework.proto.OpDesc.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OpDesc::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:paddle.framework.proto.OpDesc.type)
}

// repeated .paddle.framework.proto.OpDesc.Var inputs = 1;
inline int OpDesc::_internal_inputs_size() const {
  return _impl_.inputs_.size();
}
inline int OpDesc::inputs_size() const {
  return _internal_inputs_size();
}
inline void OpDesc::clear_inputs() {
  _impl_.inputs_.Clear();
}
inline ::paddle::framework::proto::OpDesc_Var* OpDesc::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.OpDesc.inputs)
  return _impl_.inputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpDesc_Var >*
OpDesc::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:paddle.framework.proto.OpDesc.inputs)
  return &_impl_.inputs_;
}
inline const ::paddle::framework::proto::OpDesc_Var& OpDesc::_internal_inputs(int index) const {
  return _impl_.inputs_.Get(index);
}
inline const ::paddle::framework::proto::OpDesc_Var& OpDesc::inputs(int index) const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpDesc.inputs)
  return _internal_inputs(index);
}
inline ::paddle::framework::proto::OpDesc_Var* OpDesc::_internal_add_inputs() {
  return _impl_.inputs_.Add();
}
inline ::paddle::framework::proto::OpDesc_Var* OpDesc::add_inputs() {
  ::paddle::framework::proto::OpDesc_Var* _add = _internal_add_inputs();
  // @@protoc_insertion_point(field_add:paddle.framework.proto.OpDesc.inputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpDesc_Var >&
OpDesc::inputs() const {
  // @@protoc_insertion_point(field_list:paddle.framework.proto.OpDesc.inputs)
  return _impl_.inputs_;
}

// repeated .paddle.framework.proto.OpDesc.Var outputs = 2;
inline int OpDesc::_internal_outputs_size() const {
  return _impl_.outputs_.size();
}
inline int OpDesc::outputs_size() const {
  return _internal_outputs_size();
}
inline void OpDesc::clear_outputs() {
  _impl_.outputs_.Clear();
}
inline ::paddle::framework::proto::OpDesc_Var* OpDesc::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.OpDesc.outputs)
  return _impl_.outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpDesc_Var >*
OpDesc::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:paddle.framework.proto.OpDesc.outputs)
  return &_impl_.outputs_;
}
inline const ::paddle::framework::proto::OpDesc_Var& OpDesc::_internal_outputs(int index) const {
  return _impl_.outputs_.Get(index);
}
inline const ::paddle::framework::proto::OpDesc_Var& OpDesc::outputs(int index) const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpDesc.outputs)
  return _internal_outputs(index);
}
inline ::paddle::framework::proto::OpDesc_Var* OpDesc::_internal_add_outputs() {
  return _impl_.outputs_.Add();
}
inline ::paddle::framework::proto::OpDesc_Var* OpDesc::add_outputs() {
  ::paddle::framework::proto::OpDesc_Var* _add = _internal_add_outputs();
  // @@protoc_insertion_point(field_add:paddle.framework.proto.OpDesc.outputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpDesc_Var >&
OpDesc::outputs() const {
  // @@protoc_insertion_point(field_list:paddle.framework.proto.OpDesc.outputs)
  return _impl_.outputs_;
}

// repeated .paddle.framework.proto.OpDesc.Attr attrs = 4;
inline int OpDesc::_internal_attrs_size() const {
  return _impl_.attrs_.size();
}
inline int OpDesc::attrs_size() const {
  return _internal_attrs_size();
}
inline void OpDesc::clear_attrs() {
  _impl_.attrs_.Clear();
}
inline ::paddle::framework::proto::OpDesc_Attr* OpDesc::mutable_attrs(int index) {
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.OpDesc.attrs)
  return _impl_.attrs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpDesc_Attr >*
OpDesc::mutable_attrs() {
  // @@protoc_insertion_point(field_mutable_list:paddle.framework.proto.OpDesc.attrs)
  return &_impl_.attrs_;
}
inline const ::paddle::framework::proto::OpDesc_Attr& OpDesc::_internal_attrs(int index) const {
  return _impl_.attrs_.Get(index);
}
inline const ::paddle::framework::proto::OpDesc_Attr& OpDesc::attrs(int index) const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpDesc.attrs)
  return _internal_attrs(index);
}
inline ::paddle::framework::proto::OpDesc_Attr* OpDesc::_internal_add_attrs() {
  return _impl_.attrs_.Add();
}
inline ::paddle::framework::proto::OpDesc_Attr* OpDesc::add_attrs() {
  ::paddle::framework::proto::OpDesc_Attr* _add = _internal_add_attrs();
  // @@protoc_insertion_point(field_add:paddle.framework.proto.OpDesc.attrs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpDesc_Attr >&
OpDesc::attrs() const {
  // @@protoc_insertion_point(field_list:paddle.framework.proto.OpDesc.attrs)
  return _impl_.attrs_;
}

// optional bool is_target = 5 [default = false];
inline bool OpDesc::_internal_has_is_target() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OpDesc::has_is_target() const {
  return _internal_has_is_target();
}
inline void OpDesc::clear_is_target() {
  _impl_.is_target_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool OpDesc::_internal_is_target() const {
  return _impl_.is_target_;
}
inline bool OpDesc::is_target() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpDesc.is_target)
  return _internal_is_target();
}
inline void OpDesc::_internal_set_is_target(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.is_target_ = value;
}
inline void OpDesc::set_is_target(bool value) {
  _internal_set_is_target(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpDesc.is_target)
}

// -------------------------------------------------------------------

// OpProto_Var

// required string name = 1;
inline bool OpProto_Var::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OpProto_Var::has_name() const {
  return _internal_has_name();
}
inline void OpProto_Var::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OpProto_Var::name() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpProto.Var.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpProto_Var::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpProto.Var.name)
}
inline std::string* OpProto_Var::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.OpProto.Var.name)
  return _s;
}
inline const std::string& OpProto_Var::_internal_name() const {
  return _impl_.name_.Get();
}
inline void OpProto_Var::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* OpProto_Var::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* OpProto_Var::release_name() {
  // @@protoc_insertion_point(field_release:paddle.framework.proto.OpProto.Var.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OpProto_Var::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:paddle.framework.proto.OpProto.Var.name)
}

// required string comment = 2;
inline bool OpProto_Var::_internal_has_comment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OpProto_Var::has_comment() const {
  return _internal_has_comment();
}
inline void OpProto_Var::clear_comment() {
  _impl_.comment_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& OpProto_Var::comment() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpProto.Var.comment)
  return _internal_comment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpProto_Var::set_comment(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpProto.Var.comment)
}
inline std::string* OpProto_Var::mutable_comment() {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.OpProto.Var.comment)
  return _s;
}
inline const std::string& OpProto_Var::_internal_comment() const {
  return _impl_.comment_.Get();
}
inline void OpProto_Var::_internal_set_comment(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.comment_.Set(value, GetArenaForAllocation());
}
inline std::string* OpProto_Var::_internal_mutable_comment() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.comment_.Mutable(GetArenaForAllocation());
}
inline std::string* OpProto_Var::release_comment() {
  // @@protoc_insertion_point(field_release:paddle.framework.proto.OpProto.Var.comment)
  if (!_internal_has_comment()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.comment_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OpProto_Var::set_allocated_comment(std::string* comment) {
  if (comment != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:paddle.framework.proto.OpProto.Var.comment)
}

// optional bool duplicable = 3 [default = false];
inline bool OpProto_Var::_internal_has_duplicable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool OpProto_Var::has_duplicable() const {
  return _internal_has_duplicable();
}
inline void OpProto_Var::clear_duplicable() {
  _impl_.duplicable_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool OpProto_Var::_internal_duplicable() const {
  return _impl_.duplicable_;
}
inline bool OpProto_Var::duplicable() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpProto.Var.duplicable)
  return _internal_duplicable();
}
inline void OpProto_Var::_internal_set_duplicable(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.duplicable_ = value;
}
inline void OpProto_Var::set_duplicable(bool value) {
  _internal_set_duplicable(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpProto.Var.duplicable)
}

// optional bool intermediate = 4 [default = false];
inline bool OpProto_Var::_internal_has_intermediate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool OpProto_Var::has_intermediate() const {
  return _internal_has_intermediate();
}
inline void OpProto_Var::clear_intermediate() {
  _impl_.intermediate_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool OpProto_Var::_internal_intermediate() const {
  return _impl_.intermediate_;
}
inline bool OpProto_Var::intermediate() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpProto.Var.intermediate)
  return _internal_intermediate();
}
inline void OpProto_Var::_internal_set_intermediate(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.intermediate_ = value;
}
inline void OpProto_Var::set_intermediate(bool value) {
  _internal_set_intermediate(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpProto.Var.intermediate)
}

// optional bool dispensable = 5 [default = false];
inline bool OpProto_Var::_internal_has_dispensable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool OpProto_Var::has_dispensable() const {
  return _internal_has_dispensable();
}
inline void OpProto_Var::clear_dispensable() {
  _impl_.dispensable_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool OpProto_Var::_internal_dispensable() const {
  return _impl_.dispensable_;
}
inline bool OpProto_Var::dispensable() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpProto.Var.dispensable)
  return _internal_dispensable();
}
inline void OpProto_Var::_internal_set_dispensable(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.dispensable_ = value;
}
inline void OpProto_Var::set_dispensable(bool value) {
  _internal_set_dispensable(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpProto.Var.dispensable)
}

// optional bool extra = 6 [default = false];
inline bool OpProto_Var::_internal_has_extra() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool OpProto_Var::has_extra() const {
  return _internal_has_extra();
}
inline void OpProto_Var::clear_extra() {
  _impl_.extra_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool OpProto_Var::_internal_extra() const {
  return _impl_.extra_;
}
inline bool OpProto_Var::extra() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpProto.Var.extra)
  return _internal_extra();
}
inline void OpProto_Var::_internal_set_extra(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.extra_ = value;
}
inline void OpProto_Var::set_extra(bool value) {
  _internal_set_extra(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpProto.Var.extra)
}

// optional bool quant = 7 [default = false];
inline bool OpProto_Var::_internal_has_quant() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool OpProto_Var::has_quant() const {
  return _internal_has_quant();
}
inline void OpProto_Var::clear_quant() {
  _impl_.quant_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool OpProto_Var::_internal_quant() const {
  return _impl_.quant_;
}
inline bool OpProto_Var::quant() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpProto.Var.quant)
  return _internal_quant();
}
inline void OpProto_Var::_internal_set_quant(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.quant_ = value;
}
inline void OpProto_Var::set_quant(bool value) {
  _internal_set_quant(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpProto.Var.quant)
}

// -------------------------------------------------------------------

// OpProto_Attr

// required string name = 1;
inline bool OpProto_Attr::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OpProto_Attr::has_name() const {
  return _internal_has_name();
}
inline void OpProto_Attr::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OpProto_Attr::name() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpProto.Attr.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpProto_Attr::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpProto.Attr.name)
}
inline std::string* OpProto_Attr::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.OpProto.Attr.name)
  return _s;
}
inline const std::string& OpProto_Attr::_internal_name() const {
  return _impl_.name_.Get();
}
inline void OpProto_Attr::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* OpProto_Attr::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* OpProto_Attr::release_name() {
  // @@protoc_insertion_point(field_release:paddle.framework.proto.OpProto.Attr.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OpProto_Attr::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:paddle.framework.proto.OpProto.Attr.name)
}

// required .paddle.framework.proto.AttrType type = 2;
inline bool OpProto_Attr::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool OpProto_Attr::has_type() const {
  return _internal_has_type();
}
inline void OpProto_Attr::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::paddle::framework::proto::AttrType OpProto_Attr::_internal_type() const {
  return static_cast< ::paddle::framework::proto::AttrType >(_impl_.type_);
}
inline ::paddle::framework::proto::AttrType OpProto_Attr::type() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpProto.Attr.type)
  return _internal_type();
}
inline void OpProto_Attr::_internal_set_type(::paddle::framework::proto::AttrType value) {
  assert(::paddle::framework::proto::AttrType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.type_ = value;
}
inline void OpProto_Attr::set_type(::paddle::framework::proto::AttrType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpProto.Attr.type)
}

// required string comment = 3;
inline bool OpProto_Attr::_internal_has_comment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OpProto_Attr::has_comment() const {
  return _internal_has_comment();
}
inline void OpProto_Attr::clear_comment() {
  _impl_.comment_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& OpProto_Attr::comment() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpProto.Attr.comment)
  return _internal_comment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpProto_Attr::set_comment(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpProto.Attr.comment)
}
inline std::string* OpProto_Attr::mutable_comment() {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.OpProto.Attr.comment)
  return _s;
}
inline const std::string& OpProto_Attr::_internal_comment() const {
  return _impl_.comment_.Get();
}
inline void OpProto_Attr::_internal_set_comment(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.comment_.Set(value, GetArenaForAllocation());
}
inline std::string* OpProto_Attr::_internal_mutable_comment() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.comment_.Mutable(GetArenaForAllocation());
}
inline std::string* OpProto_Attr::release_comment() {
  // @@protoc_insertion_point(field_release:paddle.framework.proto.OpProto.Attr.comment)
  if (!_internal_has_comment()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.comment_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OpProto_Attr::set_allocated_comment(std::string* comment) {
  if (comment != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:paddle.framework.proto.OpProto.Attr.comment)
}

// optional bool generated = 4 [default = false];
inline bool OpProto_Attr::_internal_has_generated() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool OpProto_Attr::has_generated() const {
  return _internal_has_generated();
}
inline void OpProto_Attr::clear_generated() {
  _impl_.generated_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool OpProto_Attr::_internal_generated() const {
  return _impl_.generated_;
}
inline bool OpProto_Attr::generated() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpProto.Attr.generated)
  return _internal_generated();
}
inline void OpProto_Attr::_internal_set_generated(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.generated_ = value;
}
inline void OpProto_Attr::set_generated(bool value) {
  _internal_set_generated(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpProto.Attr.generated)
}

// optional bool extra = 5 [default = false];
inline bool OpProto_Attr::_internal_has_extra() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool OpProto_Attr::has_extra() const {
  return _internal_has_extra();
}
inline void OpProto_Attr::clear_extra() {
  _impl_.extra_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool OpProto_Attr::_internal_extra() const {
  return _impl_.extra_;
}
inline bool OpProto_Attr::extra() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpProto.Attr.extra)
  return _internal_extra();
}
inline void OpProto_Attr::_internal_set_extra(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.extra_ = value;
}
inline void OpProto_Attr::set_extra(bool value) {
  _internal_set_extra(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpProto.Attr.extra)
}

// optional bool quant = 6 [default = false];
inline bool OpProto_Attr::_internal_has_quant() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool OpProto_Attr::has_quant() const {
  return _internal_has_quant();
}
inline void OpProto_Attr::clear_quant() {
  _impl_.quant_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool OpProto_Attr::_internal_quant() const {
  return _impl_.quant_;
}
inline bool OpProto_Attr::quant() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpProto.Attr.quant)
  return _internal_quant();
}
inline void OpProto_Attr::_internal_set_quant(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.quant_ = value;
}
inline void OpProto_Attr::set_quant(bool value) {
  _internal_set_quant(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpProto.Attr.quant)
}

// optional bool support_tensor = 7 [default = false];
inline bool OpProto_Attr::_internal_has_support_tensor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool OpProto_Attr::has_support_tensor() const {
  return _internal_has_support_tensor();
}
inline void OpProto_Attr::clear_support_tensor() {
  _impl_.support_tensor_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool OpProto_Attr::_internal_support_tensor() const {
  return _impl_.support_tensor_;
}
inline bool OpProto_Attr::support_tensor() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpProto.Attr.support_tensor)
  return _internal_support_tensor();
}
inline void OpProto_Attr::_internal_set_support_tensor(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.support_tensor_ = value;
}
inline void OpProto_Attr::set_support_tensor(bool value) {
  _internal_set_support_tensor(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpProto.Attr.support_tensor)
}

// -------------------------------------------------------------------

// OpProto

// required string type = 1;
inline bool OpProto::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OpProto::has_type() const {
  return _internal_has_type();
}
inline void OpProto::clear_type() {
  _impl_.type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OpProto::type() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpProto.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpProto::set_type(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpProto.type)
}
inline std::string* OpProto::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.OpProto.type)
  return _s;
}
inline const std::string& OpProto::_internal_type() const {
  return _impl_.type_.Get();
}
inline void OpProto::_internal_set_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* OpProto::_internal_mutable_type() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* OpProto::release_type() {
  // @@protoc_insertion_point(field_release:paddle.framework.proto.OpProto.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OpProto::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:paddle.framework.proto.OpProto.type)
}

// repeated .paddle.framework.proto.OpProto.Var inputs = 2;
inline int OpProto::_internal_inputs_size() const {
  return _impl_.inputs_.size();
}
inline int OpProto::inputs_size() const {
  return _internal_inputs_size();
}
inline void OpProto::clear_inputs() {
  _impl_.inputs_.Clear();
}
inline ::paddle::framework::proto::OpProto_Var* OpProto::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.OpProto.inputs)
  return _impl_.inputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpProto_Var >*
OpProto::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:paddle.framework.proto.OpProto.inputs)
  return &_impl_.inputs_;
}
inline const ::paddle::framework::proto::OpProto_Var& OpProto::_internal_inputs(int index) const {
  return _impl_.inputs_.Get(index);
}
inline const ::paddle::framework::proto::OpProto_Var& OpProto::inputs(int index) const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpProto.inputs)
  return _internal_inputs(index);
}
inline ::paddle::framework::proto::OpProto_Var* OpProto::_internal_add_inputs() {
  return _impl_.inputs_.Add();
}
inline ::paddle::framework::proto::OpProto_Var* OpProto::add_inputs() {
  ::paddle::framework::proto::OpProto_Var* _add = _internal_add_inputs();
  // @@protoc_insertion_point(field_add:paddle.framework.proto.OpProto.inputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpProto_Var >&
OpProto::inputs() const {
  // @@protoc_insertion_point(field_list:paddle.framework.proto.OpProto.inputs)
  return _impl_.inputs_;
}

// repeated .paddle.framework.proto.OpProto.Var outputs = 3;
inline int OpProto::_internal_outputs_size() const {
  return _impl_.outputs_.size();
}
inline int OpProto::outputs_size() const {
  return _internal_outputs_size();
}
inline void OpProto::clear_outputs() {
  _impl_.outputs_.Clear();
}
inline ::paddle::framework::proto::OpProto_Var* OpProto::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.OpProto.outputs)
  return _impl_.outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpProto_Var >*
OpProto::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:paddle.framework.proto.OpProto.outputs)
  return &_impl_.outputs_;
}
inline const ::paddle::framework::proto::OpProto_Var& OpProto::_internal_outputs(int index) const {
  return _impl_.outputs_.Get(index);
}
inline const ::paddle::framework::proto::OpProto_Var& OpProto::outputs(int index) const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpProto.outputs)
  return _internal_outputs(index);
}
inline ::paddle::framework::proto::OpProto_Var* OpProto::_internal_add_outputs() {
  return _impl_.outputs_.Add();
}
inline ::paddle::framework::proto::OpProto_Var* OpProto::add_outputs() {
  ::paddle::framework::proto::OpProto_Var* _add = _internal_add_outputs();
  // @@protoc_insertion_point(field_add:paddle.framework.proto.OpProto.outputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpProto_Var >&
OpProto::outputs() const {
  // @@protoc_insertion_point(field_list:paddle.framework.proto.OpProto.outputs)
  return _impl_.outputs_;
}

// repeated .paddle.framework.proto.OpProto.Attr attrs = 4;
inline int OpProto::_internal_attrs_size() const {
  return _impl_.attrs_.size();
}
inline int OpProto::attrs_size() const {
  return _internal_attrs_size();
}
inline void OpProto::clear_attrs() {
  _impl_.attrs_.Clear();
}
inline ::paddle::framework::proto::OpProto_Attr* OpProto::mutable_attrs(int index) {
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.OpProto.attrs)
  return _impl_.attrs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpProto_Attr >*
OpProto::mutable_attrs() {
  // @@protoc_insertion_point(field_mutable_list:paddle.framework.proto.OpProto.attrs)
  return &_impl_.attrs_;
}
inline const ::paddle::framework::proto::OpProto_Attr& OpProto::_internal_attrs(int index) const {
  return _impl_.attrs_.Get(index);
}
inline const ::paddle::framework::proto::OpProto_Attr& OpProto::attrs(int index) const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpProto.attrs)
  return _internal_attrs(index);
}
inline ::paddle::framework::proto::OpProto_Attr* OpProto::_internal_add_attrs() {
  return _impl_.attrs_.Add();
}
inline ::paddle::framework::proto::OpProto_Attr* OpProto::add_attrs() {
  ::paddle::framework::proto::OpProto_Attr* _add = _internal_add_attrs();
  // @@protoc_insertion_point(field_add:paddle.framework.proto.OpProto.attrs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpProto_Attr >&
OpProto::attrs() const {
  // @@protoc_insertion_point(field_list:paddle.framework.proto.OpProto.attrs)
  return _impl_.attrs_;
}

// required string comment = 5;
inline bool OpProto::_internal_has_comment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OpProto::has_comment() const {
  return _internal_has_comment();
}
inline void OpProto::clear_comment() {
  _impl_.comment_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& OpProto::comment() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpProto.comment)
  return _internal_comment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpProto::set_comment(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpProto.comment)
}
inline std::string* OpProto::mutable_comment() {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.OpProto.comment)
  return _s;
}
inline const std::string& OpProto::_internal_comment() const {
  return _impl_.comment_.Get();
}
inline void OpProto::_internal_set_comment(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.comment_.Set(value, GetArenaForAllocation());
}
inline std::string* OpProto::_internal_mutable_comment() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.comment_.Mutable(GetArenaForAllocation());
}
inline std::string* OpProto::release_comment() {
  // @@protoc_insertion_point(field_release:paddle.framework.proto.OpProto.comment)
  if (!_internal_has_comment()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.comment_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OpProto::set_allocated_comment(std::string* comment) {
  if (comment != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:paddle.framework.proto.OpProto.comment)
}

// -------------------------------------------------------------------

// VarType_TensorDesc

// required .paddle.framework.proto.VarType.Type data_type = 1;
inline bool VarType_TensorDesc::_internal_has_data_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VarType_TensorDesc::has_data_type() const {
  return _internal_has_data_type();
}
inline void VarType_TensorDesc::clear_data_type() {
  _impl_.data_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::paddle::framework::proto::VarType_Type VarType_TensorDesc::_internal_data_type() const {
  return static_cast< ::paddle::framework::proto::VarType_Type >(_impl_.data_type_);
}
inline ::paddle::framework::proto::VarType_Type VarType_TensorDesc::data_type() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.VarType.TensorDesc.data_type)
  return _internal_data_type();
}
inline void VarType_TensorDesc::_internal_set_data_type(::paddle::framework::proto::VarType_Type value) {
  assert(::paddle::framework::proto::VarType_Type_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_type_ = value;
}
inline void VarType_TensorDesc::set_data_type(::paddle::framework::proto::VarType_Type value) {
  _internal_set_data_type(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.VarType.TensorDesc.data_type)
}

// repeated int64 dims = 2;
inline int VarType_TensorDesc::_internal_dims_size() const {
  return _impl_.dims_.size();
}
inline int VarType_TensorDesc::dims_size() const {
  return _internal_dims_size();
}
inline void VarType_TensorDesc::clear_dims() {
  _impl_.dims_.Clear();
}
inline int64_t VarType_TensorDesc::_internal_dims(int index) const {
  return _impl_.dims_.Get(index);
}
inline int64_t VarType_TensorDesc::dims(int index) const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.VarType.TensorDesc.dims)
  return _internal_dims(index);
}
inline void VarType_TensorDesc::set_dims(int index, int64_t value) {
  _impl_.dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.VarType.TensorDesc.dims)
}
inline void VarType_TensorDesc::_internal_add_dims(int64_t value) {
  _impl_.dims_.Add(value);
}
inline void VarType_TensorDesc::add_dims(int64_t value) {
  _internal_add_dims(value);
  // @@protoc_insertion_point(field_add:paddle.framework.proto.VarType.TensorDesc.dims)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
VarType_TensorDesc::_internal_dims() const {
  return _impl_.dims_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
VarType_TensorDesc::dims() const {
  // @@protoc_insertion_point(field_list:paddle.framework.proto.VarType.TensorDesc.dims)
  return _internal_dims();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
VarType_TensorDesc::_internal_mutable_dims() {
  return &_impl_.dims_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
VarType_TensorDesc::mutable_dims() {
  // @@protoc_insertion_point(field_mutable_list:paddle.framework.proto.VarType.TensorDesc.dims)
  return _internal_mutable_dims();
}

// -------------------------------------------------------------------

// VarType_DenseTensorDesc

// required .paddle.framework.proto.VarType.TensorDesc tensor = 1;
inline bool VarType_DenseTensorDesc::_internal_has_tensor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tensor_ != nullptr);
  return value;
}
inline bool VarType_DenseTensorDesc::has_tensor() const {
  return _internal_has_tensor();
}
inline void VarType_DenseTensorDesc::clear_tensor() {
  if (_impl_.tensor_ != nullptr) _impl_.tensor_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::paddle::framework::proto::VarType_TensorDesc& VarType_DenseTensorDesc::_internal_tensor() const {
  const ::paddle::framework::proto::VarType_TensorDesc* p = _impl_.tensor_;
  return p != nullptr ? *p : reinterpret_cast<const ::paddle::framework::proto::VarType_TensorDesc&>(
      ::paddle::framework::proto::_VarType_TensorDesc_default_instance_);
}
inline const ::paddle::framework::proto::VarType_TensorDesc& VarType_DenseTensorDesc::tensor() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.VarType.DenseTensorDesc.tensor)
  return _internal_tensor();
}
inline void VarType_DenseTensorDesc::unsafe_arena_set_allocated_tensor(
    ::paddle::framework::proto::VarType_TensorDesc* tensor) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tensor_);
  }
  _impl_.tensor_ = tensor;
  if (tensor) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:paddle.framework.proto.VarType.DenseTensorDesc.tensor)
}
inline ::paddle::framework::proto::VarType_TensorDesc* VarType_DenseTensorDesc::release_tensor() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::paddle::framework::proto::VarType_TensorDesc* temp = _impl_.tensor_;
  _impl_.tensor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::paddle::framework::proto::VarType_TensorDesc* VarType_DenseTensorDesc::unsafe_arena_release_tensor() {
  // @@protoc_insertion_point(field_release:paddle.framework.proto.VarType.DenseTensorDesc.tensor)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::paddle::framework::proto::VarType_TensorDesc* temp = _impl_.tensor_;
  _impl_.tensor_ = nullptr;
  return temp;
}
inline ::paddle::framework::proto::VarType_TensorDesc* VarType_DenseTensorDesc::_internal_mutable_tensor() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.tensor_ == nullptr) {
    auto* p = CreateMaybeMessage<::paddle::framework::proto::VarType_TensorDesc>(GetArenaForAllocation());
    _impl_.tensor_ = p;
  }
  return _impl_.tensor_;
}
inline ::paddle::framework::proto::VarType_TensorDesc* VarType_DenseTensorDesc::mutable_tensor() {
  ::paddle::framework::proto::VarType_TensorDesc* _msg = _internal_mutable_tensor();
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.VarType.DenseTensorDesc.tensor)
  return _msg;
}
inline void VarType_DenseTensorDesc::set_allocated_tensor(::paddle::framework::proto::VarType_TensorDesc* tensor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tensor_;
  }
  if (tensor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tensor);
    if (message_arena != submessage_arena) {
      tensor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tensor, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.tensor_ = tensor;
  // @@protoc_insertion_point(field_set_allocated:paddle.framework.proto.VarType.DenseTensorDesc.tensor)
}

// optional int32 legacy_lod_level = 2 [default = 0];
inline bool VarType_DenseTensorDesc::_internal_has_legacy_lod_level() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VarType_DenseTensorDesc::has_legacy_lod_level() const {
  return _internal_has_legacy_lod_level();
}
inline void VarType_DenseTensorDesc::clear_legacy_lod_level() {
  _impl_.legacy_lod_level_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t VarType_DenseTensorDesc::_internal_legacy_lod_level() const {
  return _impl_.legacy_lod_level_;
}
inline int32_t VarType_DenseTensorDesc::legacy_lod_level() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.VarType.DenseTensorDesc.legacy_lod_level)
  return _internal_legacy_lod_level();
}
inline void VarType_DenseTensorDesc::_internal_set_legacy_lod_level(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.legacy_lod_level_ = value;
}
inline void VarType_DenseTensorDesc::set_legacy_lod_level(int32_t value) {
  _internal_set_legacy_lod_level(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.VarType.DenseTensorDesc.legacy_lod_level)
}

// -------------------------------------------------------------------

// VarType_DenseTensorArrayDesc

// required .paddle.framework.proto.VarType.TensorDesc tensor = 1;
inline bool VarType_DenseTensorArrayDesc::_internal_has_tensor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tensor_ != nullptr);
  return value;
}
inline bool VarType_DenseTensorArrayDesc::has_tensor() const {
  return _internal_has_tensor();
}
inline void VarType_DenseTensorArrayDesc::clear_tensor() {
  if (_impl_.tensor_ != nullptr) _impl_.tensor_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::paddle::framework::proto::VarType_TensorDesc& VarType_DenseTensorArrayDesc::_internal_tensor() const {
  const ::paddle::framework::proto::VarType_TensorDesc* p = _impl_.tensor_;
  return p != nullptr ? *p : reinterpret_cast<const ::paddle::framework::proto::VarType_TensorDesc&>(
      ::paddle::framework::proto::_VarType_TensorDesc_default_instance_);
}
inline const ::paddle::framework::proto::VarType_TensorDesc& VarType_DenseTensorArrayDesc::tensor() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.VarType.DenseTensorArrayDesc.tensor)
  return _internal_tensor();
}
inline void VarType_DenseTensorArrayDesc::unsafe_arena_set_allocated_tensor(
    ::paddle::framework::proto::VarType_TensorDesc* tensor) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tensor_);
  }
  _impl_.tensor_ = tensor;
  if (tensor) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:paddle.framework.proto.VarType.DenseTensorArrayDesc.tensor)
}
inline ::paddle::framework::proto::VarType_TensorDesc* VarType_DenseTensorArrayDesc::release_tensor() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::paddle::framework::proto::VarType_TensorDesc* temp = _impl_.tensor_;
  _impl_.tensor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::paddle::framework::proto::VarType_TensorDesc* VarType_DenseTensorArrayDesc::unsafe_arena_release_tensor() {
  // @@protoc_insertion_point(field_release:paddle.framework.proto.VarType.DenseTensorArrayDesc.tensor)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::paddle::framework::proto::VarType_TensorDesc* temp = _impl_.tensor_;
  _impl_.tensor_ = nullptr;
  return temp;
}
inline ::paddle::framework::proto::VarType_TensorDesc* VarType_DenseTensorArrayDesc::_internal_mutable_tensor() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.tensor_ == nullptr) {
    auto* p = CreateMaybeMessage<::paddle::framework::proto::VarType_TensorDesc>(GetArenaForAllocation());
    _impl_.tensor_ = p;
  }
  return _impl_.tensor_;
}
inline ::paddle::framework::proto::VarType_TensorDesc* VarType_DenseTensorArrayDesc::mutable_tensor() {
  ::paddle::framework::proto::VarType_TensorDesc* _msg = _internal_mutable_tensor();
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.VarType.DenseTensorArrayDesc.tensor)
  return _msg;
}
inline void VarType_DenseTensorArrayDesc::set_allocated_tensor(::paddle::framework::proto::VarType_TensorDesc* tensor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tensor_;
  }
  if (tensor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tensor);
    if (message_arena != submessage_arena) {
      tensor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tensor, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.tensor_ = tensor;
  // @@protoc_insertion_point(field_set_allocated:paddle.framework.proto.VarType.DenseTensorArrayDesc.tensor)
}

// optional int32 legacy_lod_level = 2 [default = 0];
inline bool VarType_DenseTensorArrayDesc::_internal_has_legacy_lod_level() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VarType_DenseTensorArrayDesc::has_legacy_lod_level() const {
  return _internal_has_legacy_lod_level();
}
inline void VarType_DenseTensorArrayDesc::clear_legacy_lod_level() {
  _impl_.legacy_lod_level_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t VarType_DenseTensorArrayDesc::_internal_legacy_lod_level() const {
  return _impl_.legacy_lod_level_;
}
inline int32_t VarType_DenseTensorArrayDesc::legacy_lod_level() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.VarType.DenseTensorArrayDesc.legacy_lod_level)
  return _internal_legacy_lod_level();
}
inline void VarType_DenseTensorArrayDesc::_internal_set_legacy_lod_level(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.legacy_lod_level_ = value;
}
inline void VarType_DenseTensorArrayDesc::set_legacy_lod_level(int32_t value) {
  _internal_set_legacy_lod_level(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.VarType.DenseTensorArrayDesc.legacy_lod_level)
}

// -------------------------------------------------------------------

// VarType_ReaderDesc

// repeated .paddle.framework.proto.VarType.DenseTensorDesc dense_tensor = 1;
inline int VarType_ReaderDesc::_internal_dense_tensor_size() const {
  return _impl_.dense_tensor_.size();
}
inline int VarType_ReaderDesc::dense_tensor_size() const {
  return _internal_dense_tensor_size();
}
inline void VarType_ReaderDesc::clear_dense_tensor() {
  _impl_.dense_tensor_.Clear();
}
inline ::paddle::framework::proto::VarType_DenseTensorDesc* VarType_ReaderDesc::mutable_dense_tensor(int index) {
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.VarType.ReaderDesc.dense_tensor)
  return _impl_.dense_tensor_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::VarType_DenseTensorDesc >*
VarType_ReaderDesc::mutable_dense_tensor() {
  // @@protoc_insertion_point(field_mutable_list:paddle.framework.proto.VarType.ReaderDesc.dense_tensor)
  return &_impl_.dense_tensor_;
}
inline const ::paddle::framework::proto::VarType_DenseTensorDesc& VarType_ReaderDesc::_internal_dense_tensor(int index) const {
  return _impl_.dense_tensor_.Get(index);
}
inline const ::paddle::framework::proto::VarType_DenseTensorDesc& VarType_ReaderDesc::dense_tensor(int index) const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.VarType.ReaderDesc.dense_tensor)
  return _internal_dense_tensor(index);
}
inline ::paddle::framework::proto::VarType_DenseTensorDesc* VarType_ReaderDesc::_internal_add_dense_tensor() {
  return _impl_.dense_tensor_.Add();
}
inline ::paddle::framework::proto::VarType_DenseTensorDesc* VarType_ReaderDesc::add_dense_tensor() {
  ::paddle::framework::proto::VarType_DenseTensorDesc* _add = _internal_add_dense_tensor();
  // @@protoc_insertion_point(field_add:paddle.framework.proto.VarType.ReaderDesc.dense_tensor)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::VarType_DenseTensorDesc >&
VarType_ReaderDesc::dense_tensor() const {
  // @@protoc_insertion_point(field_list:paddle.framework.proto.VarType.ReaderDesc.dense_tensor)
  return _impl_.dense_tensor_;
}

// -------------------------------------------------------------------

// VarType_Tuple

// repeated .paddle.framework.proto.VarType.Type element_type = 1;
inline int VarType_Tuple::_internal_element_type_size() const {
  return _impl_.element_type_.size();
}
inline int VarType_Tuple::element_type_size() const {
  return _internal_element_type_size();
}
inline void VarType_Tuple::clear_element_type() {
  _impl_.element_type_.Clear();
}
inline ::paddle::framework::proto::VarType_Type VarType_Tuple::_internal_element_type(int index) const {
  return static_cast< ::paddle::framework::proto::VarType_Type >(_impl_.element_type_.Get(index));
}
inline ::paddle::framework::proto::VarType_Type VarType_Tuple::element_type(int index) const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.VarType.Tuple.element_type)
  return _internal_element_type(index);
}
inline void VarType_Tuple::set_element_type(int index, ::paddle::framework::proto::VarType_Type value) {
  assert(::paddle::framework::proto::VarType_Type_IsValid(value));
  _impl_.element_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.VarType.Tuple.element_type)
}
inline void VarType_Tuple::_internal_add_element_type(::paddle::framework::proto::VarType_Type value) {
  assert(::paddle::framework::proto::VarType_Type_IsValid(value));
  _impl_.element_type_.Add(value);
}
inline void VarType_Tuple::add_element_type(::paddle::framework::proto::VarType_Type value) {
  _internal_add_element_type(value);
  // @@protoc_insertion_point(field_add:paddle.framework.proto.VarType.Tuple.element_type)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
VarType_Tuple::element_type() const {
  // @@protoc_insertion_point(field_list:paddle.framework.proto.VarType.Tuple.element_type)
  return _impl_.element_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
VarType_Tuple::_internal_mutable_element_type() {
  return &_impl_.element_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
VarType_Tuple::mutable_element_type() {
  // @@protoc_insertion_point(field_mutable_list:paddle.framework.proto.VarType.Tuple.element_type)
  return _internal_mutable_element_type();
}

// -------------------------------------------------------------------

// VarType

// required .paddle.framework.proto.VarType.Type type = 1;
inline bool VarType::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool VarType::has_type() const {
  return _internal_has_type();
}
inline void VarType::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::paddle::framework::proto::VarType_Type VarType::_internal_type() const {
  return static_cast< ::paddle::framework::proto::VarType_Type >(_impl_.type_);
}
inline ::paddle::framework::proto::VarType_Type VarType::type() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.VarType.type)
  return _internal_type();
}
inline void VarType::_internal_set_type(::paddle::framework::proto::VarType_Type value) {
  assert(::paddle::framework::proto::VarType_Type_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.type_ = value;
}
inline void VarType::set_type(::paddle::framework::proto::VarType_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.VarType.type)
}

// optional .paddle.framework.proto.VarType.TensorDesc selected_rows = 2;
inline bool VarType::_internal_has_selected_rows() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.selected_rows_ != nullptr);
  return value;
}
inline bool VarType::has_selected_rows() const {
  return _internal_has_selected_rows();
}
inline void VarType::clear_selected_rows() {
  if (_impl_.selected_rows_ != nullptr) _impl_.selected_rows_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::paddle::framework::proto::VarType_TensorDesc& VarType::_internal_selected_rows() const {
  const ::paddle::framework::proto::VarType_TensorDesc* p = _impl_.selected_rows_;
  return p != nullptr ? *p : reinterpret_cast<const ::paddle::framework::proto::VarType_TensorDesc&>(
      ::paddle::framework::proto::_VarType_TensorDesc_default_instance_);
}
inline const ::paddle::framework::proto::VarType_TensorDesc& VarType::selected_rows() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.VarType.selected_rows)
  return _internal_selected_rows();
}
inline void VarType::unsafe_arena_set_allocated_selected_rows(
    ::paddle::framework::proto::VarType_TensorDesc* selected_rows) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.selected_rows_);
  }
  _impl_.selected_rows_ = selected_rows;
  if (selected_rows) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:paddle.framework.proto.VarType.selected_rows)
}
inline ::paddle::framework::proto::VarType_TensorDesc* VarType::release_selected_rows() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::paddle::framework::proto::VarType_TensorDesc* temp = _impl_.selected_rows_;
  _impl_.selected_rows_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::paddle::framework::proto::VarType_TensorDesc* VarType::unsafe_arena_release_selected_rows() {
  // @@protoc_insertion_point(field_release:paddle.framework.proto.VarType.selected_rows)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::paddle::framework::proto::VarType_TensorDesc* temp = _impl_.selected_rows_;
  _impl_.selected_rows_ = nullptr;
  return temp;
}
inline ::paddle::framework::proto::VarType_TensorDesc* VarType::_internal_mutable_selected_rows() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.selected_rows_ == nullptr) {
    auto* p = CreateMaybeMessage<::paddle::framework::proto::VarType_TensorDesc>(GetArenaForAllocation());
    _impl_.selected_rows_ = p;
  }
  return _impl_.selected_rows_;
}
inline ::paddle::framework::proto::VarType_TensorDesc* VarType::mutable_selected_rows() {
  ::paddle::framework::proto::VarType_TensorDesc* _msg = _internal_mutable_selected_rows();
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.VarType.selected_rows)
  return _msg;
}
inline void VarType::set_allocated_selected_rows(::paddle::framework::proto::VarType_TensorDesc* selected_rows) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.selected_rows_;
  }
  if (selected_rows) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(selected_rows);
    if (message_arena != submessage_arena) {
      selected_rows = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, selected_rows, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.selected_rows_ = selected_rows;
  // @@protoc_insertion_point(field_set_allocated:paddle.framework.proto.VarType.selected_rows)
}

// optional .paddle.framework.proto.VarType.DenseTensorDesc dense_tensor = 3;
inline bool VarType::_internal_has_dense_tensor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dense_tensor_ != nullptr);
  return value;
}
inline bool VarType::has_dense_tensor() const {
  return _internal_has_dense_tensor();
}
inline void VarType::clear_dense_tensor() {
  if (_impl_.dense_tensor_ != nullptr) _impl_.dense_tensor_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::paddle::framework::proto::VarType_DenseTensorDesc& VarType::_internal_dense_tensor() const {
  const ::paddle::framework::proto::VarType_DenseTensorDesc* p = _impl_.dense_tensor_;
  return p != nullptr ? *p : reinterpret_cast<const ::paddle::framework::proto::VarType_DenseTensorDesc&>(
      ::paddle::framework::proto::_VarType_DenseTensorDesc_default_instance_);
}
inline const ::paddle::framework::proto::VarType_DenseTensorDesc& VarType::dense_tensor() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.VarType.dense_tensor)
  return _internal_dense_tensor();
}
inline void VarType::unsafe_arena_set_allocated_dense_tensor(
    ::paddle::framework::proto::VarType_DenseTensorDesc* dense_tensor) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dense_tensor_);
  }
  _impl_.dense_tensor_ = dense_tensor;
  if (dense_tensor) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:paddle.framework.proto.VarType.dense_tensor)
}
inline ::paddle::framework::proto::VarType_DenseTensorDesc* VarType::release_dense_tensor() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::paddle::framework::proto::VarType_DenseTensorDesc* temp = _impl_.dense_tensor_;
  _impl_.dense_tensor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::paddle::framework::proto::VarType_DenseTensorDesc* VarType::unsafe_arena_release_dense_tensor() {
  // @@protoc_insertion_point(field_release:paddle.framework.proto.VarType.dense_tensor)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::paddle::framework::proto::VarType_DenseTensorDesc* temp = _impl_.dense_tensor_;
  _impl_.dense_tensor_ = nullptr;
  return temp;
}
inline ::paddle::framework::proto::VarType_DenseTensorDesc* VarType::_internal_mutable_dense_tensor() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.dense_tensor_ == nullptr) {
    auto* p = CreateMaybeMessage<::paddle::framework::proto::VarType_DenseTensorDesc>(GetArenaForAllocation());
    _impl_.dense_tensor_ = p;
  }
  return _impl_.dense_tensor_;
}
inline ::paddle::framework::proto::VarType_DenseTensorDesc* VarType::mutable_dense_tensor() {
  ::paddle::framework::proto::VarType_DenseTensorDesc* _msg = _internal_mutable_dense_tensor();
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.VarType.dense_tensor)
  return _msg;
}
inline void VarType::set_allocated_dense_tensor(::paddle::framework::proto::VarType_DenseTensorDesc* dense_tensor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dense_tensor_;
  }
  if (dense_tensor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dense_tensor);
    if (message_arena != submessage_arena) {
      dense_tensor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dense_tensor, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.dense_tensor_ = dense_tensor;
  // @@protoc_insertion_point(field_set_allocated:paddle.framework.proto.VarType.dense_tensor)
}

// optional .paddle.framework.proto.VarType.DenseTensorArrayDesc tensor_array = 4;
inline bool VarType::_internal_has_tensor_array() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tensor_array_ != nullptr);
  return value;
}
inline bool VarType::has_tensor_array() const {
  return _internal_has_tensor_array();
}
inline void VarType::clear_tensor_array() {
  if (_impl_.tensor_array_ != nullptr) _impl_.tensor_array_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::paddle::framework::proto::VarType_DenseTensorArrayDesc& VarType::_internal_tensor_array() const {
  const ::paddle::framework::proto::VarType_DenseTensorArrayDesc* p = _impl_.tensor_array_;
  return p != nullptr ? *p : reinterpret_cast<const ::paddle::framework::proto::VarType_DenseTensorArrayDesc&>(
      ::paddle::framework::proto::_VarType_DenseTensorArrayDesc_default_instance_);
}
inline const ::paddle::framework::proto::VarType_DenseTensorArrayDesc& VarType::tensor_array() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.VarType.tensor_array)
  return _internal_tensor_array();
}
inline void VarType::unsafe_arena_set_allocated_tensor_array(
    ::paddle::framework::proto::VarType_DenseTensorArrayDesc* tensor_array) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tensor_array_);
  }
  _impl_.tensor_array_ = tensor_array;
  if (tensor_array) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:paddle.framework.proto.VarType.tensor_array)
}
inline ::paddle::framework::proto::VarType_DenseTensorArrayDesc* VarType::release_tensor_array() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::paddle::framework::proto::VarType_DenseTensorArrayDesc* temp = _impl_.tensor_array_;
  _impl_.tensor_array_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::paddle::framework::proto::VarType_DenseTensorArrayDesc* VarType::unsafe_arena_release_tensor_array() {
  // @@protoc_insertion_point(field_release:paddle.framework.proto.VarType.tensor_array)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::paddle::framework::proto::VarType_DenseTensorArrayDesc* temp = _impl_.tensor_array_;
  _impl_.tensor_array_ = nullptr;
  return temp;
}
inline ::paddle::framework::proto::VarType_DenseTensorArrayDesc* VarType::_internal_mutable_tensor_array() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.tensor_array_ == nullptr) {
    auto* p = CreateMaybeMessage<::paddle::framework::proto::VarType_DenseTensorArrayDesc>(GetArenaForAllocation());
    _impl_.tensor_array_ = p;
  }
  return _impl_.tensor_array_;
}
inline ::paddle::framework::proto::VarType_DenseTensorArrayDesc* VarType::mutable_tensor_array() {
  ::paddle::framework::proto::VarType_DenseTensorArrayDesc* _msg = _internal_mutable_tensor_array();
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.VarType.tensor_array)
  return _msg;
}
inline void VarType::set_allocated_tensor_array(::paddle::framework::proto::VarType_DenseTensorArrayDesc* tensor_array) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tensor_array_;
  }
  if (tensor_array) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tensor_array);
    if (message_arena != submessage_arena) {
      tensor_array = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tensor_array, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.tensor_array_ = tensor_array;
  // @@protoc_insertion_point(field_set_allocated:paddle.framework.proto.VarType.tensor_array)
}

// optional .paddle.framework.proto.VarType.ReaderDesc reader = 5;
inline bool VarType::_internal_has_reader() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.reader_ != nullptr);
  return value;
}
inline bool VarType::has_reader() const {
  return _internal_has_reader();
}
inline void VarType::clear_reader() {
  if (_impl_.reader_ != nullptr) _impl_.reader_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::paddle::framework::proto::VarType_ReaderDesc& VarType::_internal_reader() const {
  const ::paddle::framework::proto::VarType_ReaderDesc* p = _impl_.reader_;
  return p != nullptr ? *p : reinterpret_cast<const ::paddle::framework::proto::VarType_ReaderDesc&>(
      ::paddle::framework::proto::_VarType_ReaderDesc_default_instance_);
}
inline const ::paddle::framework::proto::VarType_ReaderDesc& VarType::reader() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.VarType.reader)
  return _internal_reader();
}
inline void VarType::unsafe_arena_set_allocated_reader(
    ::paddle::framework::proto::VarType_ReaderDesc* reader) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reader_);
  }
  _impl_.reader_ = reader;
  if (reader) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:paddle.framework.proto.VarType.reader)
}
inline ::paddle::framework::proto::VarType_ReaderDesc* VarType::release_reader() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::paddle::framework::proto::VarType_ReaderDesc* temp = _impl_.reader_;
  _impl_.reader_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::paddle::framework::proto::VarType_ReaderDesc* VarType::unsafe_arena_release_reader() {
  // @@protoc_insertion_point(field_release:paddle.framework.proto.VarType.reader)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::paddle::framework::proto::VarType_ReaderDesc* temp = _impl_.reader_;
  _impl_.reader_ = nullptr;
  return temp;
}
inline ::paddle::framework::proto::VarType_ReaderDesc* VarType::_internal_mutable_reader() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.reader_ == nullptr) {
    auto* p = CreateMaybeMessage<::paddle::framework::proto::VarType_ReaderDesc>(GetArenaForAllocation());
    _impl_.reader_ = p;
  }
  return _impl_.reader_;
}
inline ::paddle::framework::proto::VarType_ReaderDesc* VarType::mutable_reader() {
  ::paddle::framework::proto::VarType_ReaderDesc* _msg = _internal_mutable_reader();
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.VarType.reader)
  return _msg;
}
inline void VarType::set_allocated_reader(::paddle::framework::proto::VarType_ReaderDesc* reader) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.reader_;
  }
  if (reader) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reader);
    if (message_arena != submessage_arena) {
      reader = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reader, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.reader_ = reader;
  // @@protoc_insertion_point(field_set_allocated:paddle.framework.proto.VarType.reader)
}

// optional .paddle.framework.proto.VarType.Tuple tuple = 7;
inline bool VarType::_internal_has_tuple() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tuple_ != nullptr);
  return value;
}
inline bool VarType::has_tuple() const {
  return _internal_has_tuple();
}
inline void VarType::clear_tuple() {
  if (_impl_.tuple_ != nullptr) _impl_.tuple_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::paddle::framework::proto::VarType_Tuple& VarType::_internal_tuple() const {
  const ::paddle::framework::proto::VarType_Tuple* p = _impl_.tuple_;
  return p != nullptr ? *p : reinterpret_cast<const ::paddle::framework::proto::VarType_Tuple&>(
      ::paddle::framework::proto::_VarType_Tuple_default_instance_);
}
inline const ::paddle::framework::proto::VarType_Tuple& VarType::tuple() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.VarType.tuple)
  return _internal_tuple();
}
inline void VarType::unsafe_arena_set_allocated_tuple(
    ::paddle::framework::proto::VarType_Tuple* tuple) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tuple_);
  }
  _impl_.tuple_ = tuple;
  if (tuple) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:paddle.framework.proto.VarType.tuple)
}
inline ::paddle::framework::proto::VarType_Tuple* VarType::release_tuple() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::paddle::framework::proto::VarType_Tuple* temp = _impl_.tuple_;
  _impl_.tuple_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::paddle::framework::proto::VarType_Tuple* VarType::unsafe_arena_release_tuple() {
  // @@protoc_insertion_point(field_release:paddle.framework.proto.VarType.tuple)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::paddle::framework::proto::VarType_Tuple* temp = _impl_.tuple_;
  _impl_.tuple_ = nullptr;
  return temp;
}
inline ::paddle::framework::proto::VarType_Tuple* VarType::_internal_mutable_tuple() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.tuple_ == nullptr) {
    auto* p = CreateMaybeMessage<::paddle::framework::proto::VarType_Tuple>(GetArenaForAllocation());
    _impl_.tuple_ = p;
  }
  return _impl_.tuple_;
}
inline ::paddle::framework::proto::VarType_Tuple* VarType::mutable_tuple() {
  ::paddle::framework::proto::VarType_Tuple* _msg = _internal_mutable_tuple();
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.VarType.tuple)
  return _msg;
}
inline void VarType::set_allocated_tuple(::paddle::framework::proto::VarType_Tuple* tuple) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tuple_;
  }
  if (tuple) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tuple);
    if (message_arena != submessage_arena) {
      tuple = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tuple, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.tuple_ = tuple;
  // @@protoc_insertion_point(field_set_allocated:paddle.framework.proto.VarType.tuple)
}

// optional .paddle.framework.proto.VarType.TensorDesc string = 8;
inline bool VarType::_internal_has_string() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.string_ != nullptr);
  return value;
}
inline bool VarType::has_string() const {
  return _internal_has_string();
}
inline void VarType::clear_string() {
  if (_impl_.string_ != nullptr) _impl_.string_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::paddle::framework::proto::VarType_TensorDesc& VarType::_internal_string() const {
  const ::paddle::framework::proto::VarType_TensorDesc* p = _impl_.string_;
  return p != nullptr ? *p : reinterpret_cast<const ::paddle::framework::proto::VarType_TensorDesc&>(
      ::paddle::framework::proto::_VarType_TensorDesc_default_instance_);
}
inline const ::paddle::framework::proto::VarType_TensorDesc& VarType::string() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.VarType.string)
  return _internal_string();
}
inline void VarType::unsafe_arena_set_allocated_string(
    ::paddle::framework::proto::VarType_TensorDesc* string) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.string_);
  }
  _impl_.string_ = string;
  if (string) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:paddle.framework.proto.VarType.string)
}
inline ::paddle::framework::proto::VarType_TensorDesc* VarType::release_string() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::paddle::framework::proto::VarType_TensorDesc* temp = _impl_.string_;
  _impl_.string_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::paddle::framework::proto::VarType_TensorDesc* VarType::unsafe_arena_release_string() {
  // @@protoc_insertion_point(field_release:paddle.framework.proto.VarType.string)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::paddle::framework::proto::VarType_TensorDesc* temp = _impl_.string_;
  _impl_.string_ = nullptr;
  return temp;
}
inline ::paddle::framework::proto::VarType_TensorDesc* VarType::_internal_mutable_string() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.string_ == nullptr) {
    auto* p = CreateMaybeMessage<::paddle::framework::proto::VarType_TensorDesc>(GetArenaForAllocation());
    _impl_.string_ = p;
  }
  return _impl_.string_;
}
inline ::paddle::framework::proto::VarType_TensorDesc* VarType::mutable_string() {
  ::paddle::framework::proto::VarType_TensorDesc* _msg = _internal_mutable_string();
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.VarType.string)
  return _msg;
}
inline void VarType::set_allocated_string(::paddle::framework::proto::VarType_TensorDesc* string) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.string_;
  }
  if (string) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(string);
    if (message_arena != submessage_arena) {
      string = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, string, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.string_ = string;
  // @@protoc_insertion_point(field_set_allocated:paddle.framework.proto.VarType.string)
}

// optional .paddle.framework.proto.VarType.TensorDesc strings = 9;
inline bool VarType::_internal_has_strings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.strings_ != nullptr);
  return value;
}
inline bool VarType::has_strings() const {
  return _internal_has_strings();
}
inline void VarType::clear_strings() {
  if (_impl_.strings_ != nullptr) _impl_.strings_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::paddle::framework::proto::VarType_TensorDesc& VarType::_internal_strings() const {
  const ::paddle::framework::proto::VarType_TensorDesc* p = _impl_.strings_;
  return p != nullptr ? *p : reinterpret_cast<const ::paddle::framework::proto::VarType_TensorDesc&>(
      ::paddle::framework::proto::_VarType_TensorDesc_default_instance_);
}
inline const ::paddle::framework::proto::VarType_TensorDesc& VarType::strings() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.VarType.strings)
  return _internal_strings();
}
inline void VarType::unsafe_arena_set_allocated_strings(
    ::paddle::framework::proto::VarType_TensorDesc* strings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.strings_);
  }
  _impl_.strings_ = strings;
  if (strings) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:paddle.framework.proto.VarType.strings)
}
inline ::paddle::framework::proto::VarType_TensorDesc* VarType::release_strings() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::paddle::framework::proto::VarType_TensorDesc* temp = _impl_.strings_;
  _impl_.strings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::paddle::framework::proto::VarType_TensorDesc* VarType::unsafe_arena_release_strings() {
  // @@protoc_insertion_point(field_release:paddle.framework.proto.VarType.strings)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::paddle::framework::proto::VarType_TensorDesc* temp = _impl_.strings_;
  _impl_.strings_ = nullptr;
  return temp;
}
inline ::paddle::framework::proto::VarType_TensorDesc* VarType::_internal_mutable_strings() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.strings_ == nullptr) {
    auto* p = CreateMaybeMessage<::paddle::framework::proto::VarType_TensorDesc>(GetArenaForAllocation());
    _impl_.strings_ = p;
  }
  return _impl_.strings_;
}
inline ::paddle::framework::proto::VarType_TensorDesc* VarType::mutable_strings() {
  ::paddle::framework::proto::VarType_TensorDesc* _msg = _internal_mutable_strings();
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.VarType.strings)
  return _msg;
}
inline void VarType::set_allocated_strings(::paddle::framework::proto::VarType_TensorDesc* strings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.strings_;
  }
  if (strings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(strings);
    if (message_arena != submessage_arena) {
      strings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, strings, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.strings_ = strings;
  // @@protoc_insertion_point(field_set_allocated:paddle.framework.proto.VarType.strings)
}

// optional .paddle.framework.proto.VarType.TensorDesc vocab = 10;
inline bool VarType::_internal_has_vocab() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vocab_ != nullptr);
  return value;
}
inline bool VarType::has_vocab() const {
  return _internal_has_vocab();
}
inline void VarType::clear_vocab() {
  if (_impl_.vocab_ != nullptr) _impl_.vocab_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::paddle::framework::proto::VarType_TensorDesc& VarType::_internal_vocab() const {
  const ::paddle::framework::proto::VarType_TensorDesc* p = _impl_.vocab_;
  return p != nullptr ? *p : reinterpret_cast<const ::paddle::framework::proto::VarType_TensorDesc&>(
      ::paddle::framework::proto::_VarType_TensorDesc_default_instance_);
}
inline const ::paddle::framework::proto::VarType_TensorDesc& VarType::vocab() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.VarType.vocab)
  return _internal_vocab();
}
inline void VarType::unsafe_arena_set_allocated_vocab(
    ::paddle::framework::proto::VarType_TensorDesc* vocab) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vocab_);
  }
  _impl_.vocab_ = vocab;
  if (vocab) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:paddle.framework.proto.VarType.vocab)
}
inline ::paddle::framework::proto::VarType_TensorDesc* VarType::release_vocab() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::paddle::framework::proto::VarType_TensorDesc* temp = _impl_.vocab_;
  _impl_.vocab_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::paddle::framework::proto::VarType_TensorDesc* VarType::unsafe_arena_release_vocab() {
  // @@protoc_insertion_point(field_release:paddle.framework.proto.VarType.vocab)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::paddle::framework::proto::VarType_TensorDesc* temp = _impl_.vocab_;
  _impl_.vocab_ = nullptr;
  return temp;
}
inline ::paddle::framework::proto::VarType_TensorDesc* VarType::_internal_mutable_vocab() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.vocab_ == nullptr) {
    auto* p = CreateMaybeMessage<::paddle::framework::proto::VarType_TensorDesc>(GetArenaForAllocation());
    _impl_.vocab_ = p;
  }
  return _impl_.vocab_;
}
inline ::paddle::framework::proto::VarType_TensorDesc* VarType::mutable_vocab() {
  ::paddle::framework::proto::VarType_TensorDesc* _msg = _internal_mutable_vocab();
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.VarType.vocab)
  return _msg;
}
inline void VarType::set_allocated_vocab(::paddle::framework::proto::VarType_TensorDesc* vocab) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vocab_;
  }
  if (vocab) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vocab);
    if (message_arena != submessage_arena) {
      vocab = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vocab, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.vocab_ = vocab;
  // @@protoc_insertion_point(field_set_allocated:paddle.framework.proto.VarType.vocab)
}

// optional .paddle.framework.proto.VarType.TensorDesc sparse_coo = 11;
inline bool VarType::_internal_has_sparse_coo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sparse_coo_ != nullptr);
  return value;
}
inline bool VarType::has_sparse_coo() const {
  return _internal_has_sparse_coo();
}
inline void VarType::clear_sparse_coo() {
  if (_impl_.sparse_coo_ != nullptr) _impl_.sparse_coo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::paddle::framework::proto::VarType_TensorDesc& VarType::_internal_sparse_coo() const {
  const ::paddle::framework::proto::VarType_TensorDesc* p = _impl_.sparse_coo_;
  return p != nullptr ? *p : reinterpret_cast<const ::paddle::framework::proto::VarType_TensorDesc&>(
      ::paddle::framework::proto::_VarType_TensorDesc_default_instance_);
}
inline const ::paddle::framework::proto::VarType_TensorDesc& VarType::sparse_coo() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.VarType.sparse_coo)
  return _internal_sparse_coo();
}
inline void VarType::unsafe_arena_set_allocated_sparse_coo(
    ::paddle::framework::proto::VarType_TensorDesc* sparse_coo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sparse_coo_);
  }
  _impl_.sparse_coo_ = sparse_coo;
  if (sparse_coo) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:paddle.framework.proto.VarType.sparse_coo)
}
inline ::paddle::framework::proto::VarType_TensorDesc* VarType::release_sparse_coo() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::paddle::framework::proto::VarType_TensorDesc* temp = _impl_.sparse_coo_;
  _impl_.sparse_coo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::paddle::framework::proto::VarType_TensorDesc* VarType::unsafe_arena_release_sparse_coo() {
  // @@protoc_insertion_point(field_release:paddle.framework.proto.VarType.sparse_coo)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::paddle::framework::proto::VarType_TensorDesc* temp = _impl_.sparse_coo_;
  _impl_.sparse_coo_ = nullptr;
  return temp;
}
inline ::paddle::framework::proto::VarType_TensorDesc* VarType::_internal_mutable_sparse_coo() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.sparse_coo_ == nullptr) {
    auto* p = CreateMaybeMessage<::paddle::framework::proto::VarType_TensorDesc>(GetArenaForAllocation());
    _impl_.sparse_coo_ = p;
  }
  return _impl_.sparse_coo_;
}
inline ::paddle::framework::proto::VarType_TensorDesc* VarType::mutable_sparse_coo() {
  ::paddle::framework::proto::VarType_TensorDesc* _msg = _internal_mutable_sparse_coo();
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.VarType.sparse_coo)
  return _msg;
}
inline void VarType::set_allocated_sparse_coo(::paddle::framework::proto::VarType_TensorDesc* sparse_coo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sparse_coo_;
  }
  if (sparse_coo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sparse_coo);
    if (message_arena != submessage_arena) {
      sparse_coo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sparse_coo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.sparse_coo_ = sparse_coo;
  // @@protoc_insertion_point(field_set_allocated:paddle.framework.proto.VarType.sparse_coo)
}

// optional .paddle.framework.proto.VarType.TensorDesc sparse_csr = 12;
inline bool VarType::_internal_has_sparse_csr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sparse_csr_ != nullptr);
  return value;
}
inline bool VarType::has_sparse_csr() const {
  return _internal_has_sparse_csr();
}
inline void VarType::clear_sparse_csr() {
  if (_impl_.sparse_csr_ != nullptr) _impl_.sparse_csr_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::paddle::framework::proto::VarType_TensorDesc& VarType::_internal_sparse_csr() const {
  const ::paddle::framework::proto::VarType_TensorDesc* p = _impl_.sparse_csr_;
  return p != nullptr ? *p : reinterpret_cast<const ::paddle::framework::proto::VarType_TensorDesc&>(
      ::paddle::framework::proto::_VarType_TensorDesc_default_instance_);
}
inline const ::paddle::framework::proto::VarType_TensorDesc& VarType::sparse_csr() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.VarType.sparse_csr)
  return _internal_sparse_csr();
}
inline void VarType::unsafe_arena_set_allocated_sparse_csr(
    ::paddle::framework::proto::VarType_TensorDesc* sparse_csr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sparse_csr_);
  }
  _impl_.sparse_csr_ = sparse_csr;
  if (sparse_csr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:paddle.framework.proto.VarType.sparse_csr)
}
inline ::paddle::framework::proto::VarType_TensorDesc* VarType::release_sparse_csr() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::paddle::framework::proto::VarType_TensorDesc* temp = _impl_.sparse_csr_;
  _impl_.sparse_csr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::paddle::framework::proto::VarType_TensorDesc* VarType::unsafe_arena_release_sparse_csr() {
  // @@protoc_insertion_point(field_release:paddle.framework.proto.VarType.sparse_csr)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::paddle::framework::proto::VarType_TensorDesc* temp = _impl_.sparse_csr_;
  _impl_.sparse_csr_ = nullptr;
  return temp;
}
inline ::paddle::framework::proto::VarType_TensorDesc* VarType::_internal_mutable_sparse_csr() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.sparse_csr_ == nullptr) {
    auto* p = CreateMaybeMessage<::paddle::framework::proto::VarType_TensorDesc>(GetArenaForAllocation());
    _impl_.sparse_csr_ = p;
  }
  return _impl_.sparse_csr_;
}
inline ::paddle::framework::proto::VarType_TensorDesc* VarType::mutable_sparse_csr() {
  ::paddle::framework::proto::VarType_TensorDesc* _msg = _internal_mutable_sparse_csr();
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.VarType.sparse_csr)
  return _msg;
}
inline void VarType::set_allocated_sparse_csr(::paddle::framework::proto::VarType_TensorDesc* sparse_csr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sparse_csr_;
  }
  if (sparse_csr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sparse_csr);
    if (message_arena != submessage_arena) {
      sparse_csr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sparse_csr, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.sparse_csr_ = sparse_csr;
  // @@protoc_insertion_point(field_set_allocated:paddle.framework.proto.VarType.sparse_csr)
}

// -------------------------------------------------------------------

// VarDesc_Attr

// required string name = 1;
inline bool VarDesc_Attr::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VarDesc_Attr::has_name() const {
  return _internal_has_name();
}
inline void VarDesc_Attr::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VarDesc_Attr::name() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.VarDesc.Attr.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VarDesc_Attr::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:paddle.framework.proto.VarDesc.Attr.name)
}
inline std::string* VarDesc_Attr::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.VarDesc.Attr.name)
  return _s;
}
inline const std::string& VarDesc_Attr::_internal_name() const {
  return _impl_.name_.Get();
}
inline void VarDesc_Attr::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* VarDesc_Attr::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* VarDesc_Attr::release_name() {
  // @@protoc_insertion_point(field_release:paddle.framework.proto.VarDesc.Attr.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VarDesc_Attr::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:paddle.framework.proto.VarDesc.Attr.name)
}

// required .paddle.framework.proto.AttrType type = 2;
inline bool VarDesc_Attr::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool VarDesc_Attr::has_type() const {
  return _internal_has_type();
}
inline void VarDesc_Attr::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::paddle::framework::proto::AttrType VarDesc_Attr::_internal_type() const {
  return static_cast< ::paddle::framework::proto::AttrType >(_impl_.type_);
}
inline ::paddle::framework::proto::AttrType VarDesc_Attr::type() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.VarDesc.Attr.type)
  return _internal_type();
}
inline void VarDesc_Attr::_internal_set_type(::paddle::framework::proto::AttrType value) {
  assert(::paddle::framework::proto::AttrType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.type_ = value;
}
inline void VarDesc_Attr::set_type(::paddle::framework::proto::AttrType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.VarDesc.Attr.type)
}

// optional int32 i = 3;
inline bool VarDesc_Attr::_internal_has_i() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool VarDesc_Attr::has_i() const {
  return _internal_has_i();
}
inline void VarDesc_Attr::clear_i() {
  _impl_.i_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t VarDesc_Attr::_internal_i() const {
  return _impl_.i_;
}
inline int32_t VarDesc_Attr::i() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.VarDesc.Attr.i)
  return _internal_i();
}
inline void VarDesc_Attr::_internal_set_i(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.i_ = value;
}
inline void VarDesc_Attr::set_i(int32_t value) {
  _internal_set_i(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.VarDesc.Attr.i)
}

// optional string s = 4;
inline bool VarDesc_Attr::_internal_has_s() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VarDesc_Attr::has_s() const {
  return _internal_has_s();
}
inline void VarDesc_Attr::clear_s() {
  _impl_.s_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& VarDesc_Attr::s() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.VarDesc.Attr.s)
  return _internal_s();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VarDesc_Attr::set_s(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.s_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:paddle.framework.proto.VarDesc.Attr.s)
}
inline std::string* VarDesc_Attr::mutable_s() {
  std::string* _s = _internal_mutable_s();
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.VarDesc.Attr.s)
  return _s;
}
inline const std::string& VarDesc_Attr::_internal_s() const {
  return _impl_.s_.Get();
}
inline void VarDesc_Attr::_internal_set_s(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.s_.Set(value, GetArenaForAllocation());
}
inline std::string* VarDesc_Attr::_internal_mutable_s() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.s_.Mutable(GetArenaForAllocation());
}
inline std::string* VarDesc_Attr::release_s() {
  // @@protoc_insertion_point(field_release:paddle.framework.proto.VarDesc.Attr.s)
  if (!_internal_has_s()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.s_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.s_.IsDefault()) {
    _impl_.s_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VarDesc_Attr::set_allocated_s(std::string* s) {
  if (s != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.s_.SetAllocated(s, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.s_.IsDefault()) {
    _impl_.s_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:paddle.framework.proto.VarDesc.Attr.s)
}

// repeated int32 ints = 5;
inline int VarDesc_Attr::_internal_ints_size() const {
  return _impl_.ints_.size();
}
inline int VarDesc_Attr::ints_size() const {
  return _internal_ints_size();
}
inline void VarDesc_Attr::clear_ints() {
  _impl_.ints_.Clear();
}
inline int32_t VarDesc_Attr::_internal_ints(int index) const {
  return _impl_.ints_.Get(index);
}
inline int32_t VarDesc_Attr::ints(int index) const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.VarDesc.Attr.ints)
  return _internal_ints(index);
}
inline void VarDesc_Attr::set_ints(int index, int32_t value) {
  _impl_.ints_.Set(index, value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.VarDesc.Attr.ints)
}
inline void VarDesc_Attr::_internal_add_ints(int32_t value) {
  _impl_.ints_.Add(value);
}
inline void VarDesc_Attr::add_ints(int32_t value) {
  _internal_add_ints(value);
  // @@protoc_insertion_point(field_add:paddle.framework.proto.VarDesc.Attr.ints)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
VarDesc_Attr::_internal_ints() const {
  return _impl_.ints_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
VarDesc_Attr::ints() const {
  // @@protoc_insertion_point(field_list:paddle.framework.proto.VarDesc.Attr.ints)
  return _internal_ints();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
VarDesc_Attr::_internal_mutable_ints() {
  return &_impl_.ints_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
VarDesc_Attr::mutable_ints() {
  // @@protoc_insertion_point(field_mutable_list:paddle.framework.proto.VarDesc.Attr.ints)
  return _internal_mutable_ints();
}

// -------------------------------------------------------------------

// VarDesc

// required string name = 1;
inline bool VarDesc::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VarDesc::has_name() const {
  return _internal_has_name();
}
inline void VarDesc::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VarDesc::name() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.VarDesc.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VarDesc::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:paddle.framework.proto.VarDesc.name)
}
inline std::string* VarDesc::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.VarDesc.name)
  return _s;
}
inline const std::string& VarDesc::_internal_name() const {
  return _impl_.name_.Get();
}
inline void VarDesc::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* VarDesc::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* VarDesc::release_name() {
  // @@protoc_insertion_point(field_release:paddle.framework.proto.VarDesc.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VarDesc::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:paddle.framework.proto.VarDesc.name)
}

// required .paddle.framework.proto.VarType type = 2;
inline bool VarDesc::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.type_ != nullptr);
  return value;
}
inline bool VarDesc::has_type() const {
  return _internal_has_type();
}
inline void VarDesc::clear_type() {
  if (_impl_.type_ != nullptr) _impl_.type_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::paddle::framework::proto::VarType& VarDesc::_internal_type() const {
  const ::paddle::framework::proto::VarType* p = _impl_.type_;
  return p != nullptr ? *p : reinterpret_cast<const ::paddle::framework::proto::VarType&>(
      ::paddle::framework::proto::_VarType_default_instance_);
}
inline const ::paddle::framework::proto::VarType& VarDesc::type() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.VarDesc.type)
  return _internal_type();
}
inline void VarDesc::unsafe_arena_set_allocated_type(
    ::paddle::framework::proto::VarType* type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.type_);
  }
  _impl_.type_ = type;
  if (type) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:paddle.framework.proto.VarDesc.type)
}
inline ::paddle::framework::proto::VarType* VarDesc::release_type() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::paddle::framework::proto::VarType* temp = _impl_.type_;
  _impl_.type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::paddle::framework::proto::VarType* VarDesc::unsafe_arena_release_type() {
  // @@protoc_insertion_point(field_release:paddle.framework.proto.VarDesc.type)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::paddle::framework::proto::VarType* temp = _impl_.type_;
  _impl_.type_ = nullptr;
  return temp;
}
inline ::paddle::framework::proto::VarType* VarDesc::_internal_mutable_type() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.type_ == nullptr) {
    auto* p = CreateMaybeMessage<::paddle::framework::proto::VarType>(GetArenaForAllocation());
    _impl_.type_ = p;
  }
  return _impl_.type_;
}
inline ::paddle::framework::proto::VarType* VarDesc::mutable_type() {
  ::paddle::framework::proto::VarType* _msg = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.VarDesc.type)
  return _msg;
}
inline void VarDesc::set_allocated_type(::paddle::framework::proto::VarType* type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.type_;
  }
  if (type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(type);
    if (message_arena != submessage_arena) {
      type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.type_ = type;
  // @@protoc_insertion_point(field_set_allocated:paddle.framework.proto.VarDesc.type)
}

// optional bool persistable = 3 [default = false];
inline bool VarDesc::_internal_has_persistable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool VarDesc::has_persistable() const {
  return _internal_has_persistable();
}
inline void VarDesc::clear_persistable() {
  _impl_.persistable_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool VarDesc::_internal_persistable() const {
  return _impl_.persistable_;
}
inline bool VarDesc::persistable() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.VarDesc.persistable)
  return _internal_persistable();
}
inline void VarDesc::_internal_set_persistable(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.persistable_ = value;
}
inline void VarDesc::set_persistable(bool value) {
  _internal_set_persistable(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.VarDesc.persistable)
}

// optional bool need_check_feed = 4 [default = false];
inline bool VarDesc::_internal_has_need_check_feed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool VarDesc::has_need_check_feed() const {
  return _internal_has_need_check_feed();
}
inline void VarDesc::clear_need_check_feed() {
  _impl_.need_check_feed_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool VarDesc::_internal_need_check_feed() const {
  return _impl_.need_check_feed_;
}
inline bool VarDesc::need_check_feed() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.VarDesc.need_check_feed)
  return _internal_need_check_feed();
}
inline void VarDesc::_internal_set_need_check_feed(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.need_check_feed_ = value;
}
inline void VarDesc::set_need_check_feed(bool value) {
  _internal_set_need_check_feed(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.VarDesc.need_check_feed)
}

// optional bool is_parameter = 5 [default = false];
inline bool VarDesc::_internal_has_is_parameter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool VarDesc::has_is_parameter() const {
  return _internal_has_is_parameter();
}
inline void VarDesc::clear_is_parameter() {
  _impl_.is_parameter_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool VarDesc::_internal_is_parameter() const {
  return _impl_.is_parameter_;
}
inline bool VarDesc::is_parameter() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.VarDesc.is_parameter)
  return _internal_is_parameter();
}
inline void VarDesc::_internal_set_is_parameter(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.is_parameter_ = value;
}
inline void VarDesc::set_is_parameter(bool value) {
  _internal_set_is_parameter(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.VarDesc.is_parameter)
}

// optional bool stop_gradient = 6 [default = false];
inline bool VarDesc::_internal_has_stop_gradient() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool VarDesc::has_stop_gradient() const {
  return _internal_has_stop_gradient();
}
inline void VarDesc::clear_stop_gradient() {
  _impl_.stop_gradient_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool VarDesc::_internal_stop_gradient() const {
  return _impl_.stop_gradient_;
}
inline bool VarDesc::stop_gradient() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.VarDesc.stop_gradient)
  return _internal_stop_gradient();
}
inline void VarDesc::_internal_set_stop_gradient(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.stop_gradient_ = value;
}
inline void VarDesc::set_stop_gradient(bool value) {
  _internal_set_stop_gradient(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.VarDesc.stop_gradient)
}

// repeated .paddle.framework.proto.VarDesc.Attr attrs = 7;
inline int VarDesc::_internal_attrs_size() const {
  return _impl_.attrs_.size();
}
inline int VarDesc::attrs_size() const {
  return _internal_attrs_size();
}
inline void VarDesc::clear_attrs() {
  _impl_.attrs_.Clear();
}
inline ::paddle::framework::proto::VarDesc_Attr* VarDesc::mutable_attrs(int index) {
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.VarDesc.attrs)
  return _impl_.attrs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::VarDesc_Attr >*
VarDesc::mutable_attrs() {
  // @@protoc_insertion_point(field_mutable_list:paddle.framework.proto.VarDesc.attrs)
  return &_impl_.attrs_;
}
inline const ::paddle::framework::proto::VarDesc_Attr& VarDesc::_internal_attrs(int index) const {
  return _impl_.attrs_.Get(index);
}
inline const ::paddle::framework::proto::VarDesc_Attr& VarDesc::attrs(int index) const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.VarDesc.attrs)
  return _internal_attrs(index);
}
inline ::paddle::framework::proto::VarDesc_Attr* VarDesc::_internal_add_attrs() {
  return _impl_.attrs_.Add();
}
inline ::paddle::framework::proto::VarDesc_Attr* VarDesc::add_attrs() {
  ::paddle::framework::proto::VarDesc_Attr* _add = _internal_add_attrs();
  // @@protoc_insertion_point(field_add:paddle.framework.proto.VarDesc.attrs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::VarDesc_Attr >&
VarDesc::attrs() const {
  // @@protoc_insertion_point(field_list:paddle.framework.proto.VarDesc.attrs)
  return _impl_.attrs_;
}

// -------------------------------------------------------------------

// BlockDesc

// required int32 idx = 1;
inline bool BlockDesc::_internal_has_idx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BlockDesc::has_idx() const {
  return _internal_has_idx();
}
inline void BlockDesc::clear_idx() {
  _impl_.idx_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t BlockDesc::_internal_idx() const {
  return _impl_.idx_;
}
inline int32_t BlockDesc::idx() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.BlockDesc.idx)
  return _internal_idx();
}
inline void BlockDesc::_internal_set_idx(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.idx_ = value;
}
inline void BlockDesc::set_idx(int32_t value) {
  _internal_set_idx(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.BlockDesc.idx)
}

// required int32 parent_idx = 2;
inline bool BlockDesc::_internal_has_parent_idx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BlockDesc::has_parent_idx() const {
  return _internal_has_parent_idx();
}
inline void BlockDesc::clear_parent_idx() {
  _impl_.parent_idx_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t BlockDesc::_internal_parent_idx() const {
  return _impl_.parent_idx_;
}
inline int32_t BlockDesc::parent_idx() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.BlockDesc.parent_idx)
  return _internal_parent_idx();
}
inline void BlockDesc::_internal_set_parent_idx(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.parent_idx_ = value;
}
inline void BlockDesc::set_parent_idx(int32_t value) {
  _internal_set_parent_idx(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.BlockDesc.parent_idx)
}

// repeated .paddle.framework.proto.VarDesc vars = 3;
inline int BlockDesc::_internal_vars_size() const {
  return _impl_.vars_.size();
}
inline int BlockDesc::vars_size() const {
  return _internal_vars_size();
}
inline void BlockDesc::clear_vars() {
  _impl_.vars_.Clear();
}
inline ::paddle::framework::proto::VarDesc* BlockDesc::mutable_vars(int index) {
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.BlockDesc.vars)
  return _impl_.vars_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::VarDesc >*
BlockDesc::mutable_vars() {
  // @@protoc_insertion_point(field_mutable_list:paddle.framework.proto.BlockDesc.vars)
  return &_impl_.vars_;
}
inline const ::paddle::framework::proto::VarDesc& BlockDesc::_internal_vars(int index) const {
  return _impl_.vars_.Get(index);
}
inline const ::paddle::framework::proto::VarDesc& BlockDesc::vars(int index) const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.BlockDesc.vars)
  return _internal_vars(index);
}
inline ::paddle::framework::proto::VarDesc* BlockDesc::_internal_add_vars() {
  return _impl_.vars_.Add();
}
inline ::paddle::framework::proto::VarDesc* BlockDesc::add_vars() {
  ::paddle::framework::proto::VarDesc* _add = _internal_add_vars();
  // @@protoc_insertion_point(field_add:paddle.framework.proto.BlockDesc.vars)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::VarDesc >&
BlockDesc::vars() const {
  // @@protoc_insertion_point(field_list:paddle.framework.proto.BlockDesc.vars)
  return _impl_.vars_;
}

// repeated .paddle.framework.proto.OpDesc ops = 4;
inline int BlockDesc::_internal_ops_size() const {
  return _impl_.ops_.size();
}
inline int BlockDesc::ops_size() const {
  return _internal_ops_size();
}
inline void BlockDesc::clear_ops() {
  _impl_.ops_.Clear();
}
inline ::paddle::framework::proto::OpDesc* BlockDesc::mutable_ops(int index) {
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.BlockDesc.ops)
  return _impl_.ops_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpDesc >*
BlockDesc::mutable_ops() {
  // @@protoc_insertion_point(field_mutable_list:paddle.framework.proto.BlockDesc.ops)
  return &_impl_.ops_;
}
inline const ::paddle::framework::proto::OpDesc& BlockDesc::_internal_ops(int index) const {
  return _impl_.ops_.Get(index);
}
inline const ::paddle::framework::proto::OpDesc& BlockDesc::ops(int index) const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.BlockDesc.ops)
  return _internal_ops(index);
}
inline ::paddle::framework::proto::OpDesc* BlockDesc::_internal_add_ops() {
  return _impl_.ops_.Add();
}
inline ::paddle::framework::proto::OpDesc* BlockDesc::add_ops() {
  ::paddle::framework::proto::OpDesc* _add = _internal_add_ops();
  // @@protoc_insertion_point(field_add:paddle.framework.proto.BlockDesc.ops)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpDesc >&
BlockDesc::ops() const {
  // @@protoc_insertion_point(field_list:paddle.framework.proto.BlockDesc.ops)
  return _impl_.ops_;
}

// optional int32 forward_block_idx = 5 [default = -1];
inline bool BlockDesc::_internal_has_forward_block_idx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BlockDesc::has_forward_block_idx() const {
  return _internal_has_forward_block_idx();
}
inline void BlockDesc::clear_forward_block_idx() {
  _impl_.forward_block_idx_ = -1;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t BlockDesc::_internal_forward_block_idx() const {
  return _impl_.forward_block_idx_;
}
inline int32_t BlockDesc::forward_block_idx() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.BlockDesc.forward_block_idx)
  return _internal_forward_block_idx();
}
inline void BlockDesc::_internal_set_forward_block_idx(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.forward_block_idx_ = value;
}
inline void BlockDesc::set_forward_block_idx(int32_t value) {
  _internal_set_forward_block_idx(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.BlockDesc.forward_block_idx)
}

// -------------------------------------------------------------------

// OpVersion

// required int32 version = 1;
inline bool OpVersion::_internal_has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OpVersion::has_version() const {
  return _internal_has_version();
}
inline void OpVersion::clear_version() {
  _impl_.version_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t OpVersion::_internal_version() const {
  return _impl_.version_;
}
inline int32_t OpVersion::version() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpVersion.version)
  return _internal_version();
}
inline void OpVersion::_internal_set_version(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.version_ = value;
}
inline void OpVersion::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpVersion.version)
}

// -------------------------------------------------------------------

// OpVersionMap_OpVersionPair

// required string op_name = 1;
inline bool OpVersionMap_OpVersionPair::_internal_has_op_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OpVersionMap_OpVersionPair::has_op_name() const {
  return _internal_has_op_name();
}
inline void OpVersionMap_OpVersionPair::clear_op_name() {
  _impl_.op_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OpVersionMap_OpVersionPair::op_name() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpVersionMap.OpVersionPair.op_name)
  return _internal_op_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpVersionMap_OpVersionPair::set_op_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.op_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:paddle.framework.proto.OpVersionMap.OpVersionPair.op_name)
}
inline std::string* OpVersionMap_OpVersionPair::mutable_op_name() {
  std::string* _s = _internal_mutable_op_name();
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.OpVersionMap.OpVersionPair.op_name)
  return _s;
}
inline const std::string& OpVersionMap_OpVersionPair::_internal_op_name() const {
  return _impl_.op_name_.Get();
}
inline void OpVersionMap_OpVersionPair::_internal_set_op_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.op_name_.Set(value, GetArenaForAllocation());
}
inline std::string* OpVersionMap_OpVersionPair::_internal_mutable_op_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.op_name_.Mutable(GetArenaForAllocation());
}
inline std::string* OpVersionMap_OpVersionPair::release_op_name() {
  // @@protoc_insertion_point(field_release:paddle.framework.proto.OpVersionMap.OpVersionPair.op_name)
  if (!_internal_has_op_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.op_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.op_name_.IsDefault()) {
    _impl_.op_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OpVersionMap_OpVersionPair::set_allocated_op_name(std::string* op_name) {
  if (op_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.op_name_.SetAllocated(op_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.op_name_.IsDefault()) {
    _impl_.op_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:paddle.framework.proto.OpVersionMap.OpVersionPair.op_name)
}

// required .paddle.framework.proto.OpVersion op_version = 2;
inline bool OpVersionMap_OpVersionPair::_internal_has_op_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.op_version_ != nullptr);
  return value;
}
inline bool OpVersionMap_OpVersionPair::has_op_version() const {
  return _internal_has_op_version();
}
inline void OpVersionMap_OpVersionPair::clear_op_version() {
  if (_impl_.op_version_ != nullptr) _impl_.op_version_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::paddle::framework::proto::OpVersion& OpVersionMap_OpVersionPair::_internal_op_version() const {
  const ::paddle::framework::proto::OpVersion* p = _impl_.op_version_;
  return p != nullptr ? *p : reinterpret_cast<const ::paddle::framework::proto::OpVersion&>(
      ::paddle::framework::proto::_OpVersion_default_instance_);
}
inline const ::paddle::framework::proto::OpVersion& OpVersionMap_OpVersionPair::op_version() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpVersionMap.OpVersionPair.op_version)
  return _internal_op_version();
}
inline void OpVersionMap_OpVersionPair::unsafe_arena_set_allocated_op_version(
    ::paddle::framework::proto::OpVersion* op_version) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.op_version_);
  }
  _impl_.op_version_ = op_version;
  if (op_version) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:paddle.framework.proto.OpVersionMap.OpVersionPair.op_version)
}
inline ::paddle::framework::proto::OpVersion* OpVersionMap_OpVersionPair::release_op_version() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::paddle::framework::proto::OpVersion* temp = _impl_.op_version_;
  _impl_.op_version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::paddle::framework::proto::OpVersion* OpVersionMap_OpVersionPair::unsafe_arena_release_op_version() {
  // @@protoc_insertion_point(field_release:paddle.framework.proto.OpVersionMap.OpVersionPair.op_version)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::paddle::framework::proto::OpVersion* temp = _impl_.op_version_;
  _impl_.op_version_ = nullptr;
  return temp;
}
inline ::paddle::framework::proto::OpVersion* OpVersionMap_OpVersionPair::_internal_mutable_op_version() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.op_version_ == nullptr) {
    auto* p = CreateMaybeMessage<::paddle::framework::proto::OpVersion>(GetArenaForAllocation());
    _impl_.op_version_ = p;
  }
  return _impl_.op_version_;
}
inline ::paddle::framework::proto::OpVersion* OpVersionMap_OpVersionPair::mutable_op_version() {
  ::paddle::framework::proto::OpVersion* _msg = _internal_mutable_op_version();
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.OpVersionMap.OpVersionPair.op_version)
  return _msg;
}
inline void OpVersionMap_OpVersionPair::set_allocated_op_version(::paddle::framework::proto::OpVersion* op_version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.op_version_;
  }
  if (op_version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(op_version);
    if (message_arena != submessage_arena) {
      op_version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, op_version, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.op_version_ = op_version;
  // @@protoc_insertion_point(field_set_allocated:paddle.framework.proto.OpVersionMap.OpVersionPair.op_version)
}

// -------------------------------------------------------------------

// OpVersionMap

// repeated .paddle.framework.proto.OpVersionMap.OpVersionPair pair = 1;
inline int OpVersionMap::_internal_pair_size() const {
  return _impl_.pair_.size();
}
inline int OpVersionMap::pair_size() const {
  return _internal_pair_size();
}
inline void OpVersionMap::clear_pair() {
  _impl_.pair_.Clear();
}
inline ::paddle::framework::proto::OpVersionMap_OpVersionPair* OpVersionMap::mutable_pair(int index) {
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.OpVersionMap.pair)
  return _impl_.pair_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpVersionMap_OpVersionPair >*
OpVersionMap::mutable_pair() {
  // @@protoc_insertion_point(field_mutable_list:paddle.framework.proto.OpVersionMap.pair)
  return &_impl_.pair_;
}
inline const ::paddle::framework::proto::OpVersionMap_OpVersionPair& OpVersionMap::_internal_pair(int index) const {
  return _impl_.pair_.Get(index);
}
inline const ::paddle::framework::proto::OpVersionMap_OpVersionPair& OpVersionMap::pair(int index) const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.OpVersionMap.pair)
  return _internal_pair(index);
}
inline ::paddle::framework::proto::OpVersionMap_OpVersionPair* OpVersionMap::_internal_add_pair() {
  return _impl_.pair_.Add();
}
inline ::paddle::framework::proto::OpVersionMap_OpVersionPair* OpVersionMap::add_pair() {
  ::paddle::framework::proto::OpVersionMap_OpVersionPair* _add = _internal_add_pair();
  // @@protoc_insertion_point(field_add:paddle.framework.proto.OpVersionMap.pair)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::OpVersionMap_OpVersionPair >&
OpVersionMap::pair() const {
  // @@protoc_insertion_point(field_list:paddle.framework.proto.OpVersionMap.pair)
  return _impl_.pair_;
}

// -------------------------------------------------------------------

// ProgramDesc

// repeated .paddle.framework.proto.BlockDesc blocks = 1;
inline int ProgramDesc::_internal_blocks_size() const {
  return _impl_.blocks_.size();
}
inline int ProgramDesc::blocks_size() const {
  return _internal_blocks_size();
}
inline void ProgramDesc::clear_blocks() {
  _impl_.blocks_.Clear();
}
inline ::paddle::framework::proto::BlockDesc* ProgramDesc::mutable_blocks(int index) {
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.ProgramDesc.blocks)
  return _impl_.blocks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::BlockDesc >*
ProgramDesc::mutable_blocks() {
  // @@protoc_insertion_point(field_mutable_list:paddle.framework.proto.ProgramDesc.blocks)
  return &_impl_.blocks_;
}
inline const ::paddle::framework::proto::BlockDesc& ProgramDesc::_internal_blocks(int index) const {
  return _impl_.blocks_.Get(index);
}
inline const ::paddle::framework::proto::BlockDesc& ProgramDesc::blocks(int index) const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.ProgramDesc.blocks)
  return _internal_blocks(index);
}
inline ::paddle::framework::proto::BlockDesc* ProgramDesc::_internal_add_blocks() {
  return _impl_.blocks_.Add();
}
inline ::paddle::framework::proto::BlockDesc* ProgramDesc::add_blocks() {
  ::paddle::framework::proto::BlockDesc* _add = _internal_add_blocks();
  // @@protoc_insertion_point(field_add:paddle.framework.proto.ProgramDesc.blocks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::paddle::framework::proto::BlockDesc >&
ProgramDesc::blocks() const {
  // @@protoc_insertion_point(field_list:paddle.framework.proto.ProgramDesc.blocks)
  return _impl_.blocks_;
}

// optional .paddle.framework.proto.Version version = 4;
inline bool ProgramDesc::_internal_has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.version_ != nullptr);
  return value;
}
inline bool ProgramDesc::has_version() const {
  return _internal_has_version();
}
inline void ProgramDesc::clear_version() {
  if (_impl_.version_ != nullptr) _impl_.version_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::paddle::framework::proto::Version& ProgramDesc::_internal_version() const {
  const ::paddle::framework::proto::Version* p = _impl_.version_;
  return p != nullptr ? *p : reinterpret_cast<const ::paddle::framework::proto::Version&>(
      ::paddle::framework::proto::_Version_default_instance_);
}
inline const ::paddle::framework::proto::Version& ProgramDesc::version() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.ProgramDesc.version)
  return _internal_version();
}
inline void ProgramDesc::unsafe_arena_set_allocated_version(
    ::paddle::framework::proto::Version* version) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.version_);
  }
  _impl_.version_ = version;
  if (version) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:paddle.framework.proto.ProgramDesc.version)
}
inline ::paddle::framework::proto::Version* ProgramDesc::release_version() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::paddle::framework::proto::Version* temp = _impl_.version_;
  _impl_.version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::paddle::framework::proto::Version* ProgramDesc::unsafe_arena_release_version() {
  // @@protoc_insertion_point(field_release:paddle.framework.proto.ProgramDesc.version)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::paddle::framework::proto::Version* temp = _impl_.version_;
  _impl_.version_ = nullptr;
  return temp;
}
inline ::paddle::framework::proto::Version* ProgramDesc::_internal_mutable_version() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.version_ == nullptr) {
    auto* p = CreateMaybeMessage<::paddle::framework::proto::Version>(GetArenaForAllocation());
    _impl_.version_ = p;
  }
  return _impl_.version_;
}
inline ::paddle::framework::proto::Version* ProgramDesc::mutable_version() {
  ::paddle::framework::proto::Version* _msg = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.ProgramDesc.version)
  return _msg;
}
inline void ProgramDesc::set_allocated_version(::paddle::framework::proto::Version* version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.version_;
  }
  if (version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(version);
    if (message_arena != submessage_arena) {
      version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, version, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.version_ = version;
  // @@protoc_insertion_point(field_set_allocated:paddle.framework.proto.ProgramDesc.version)
}

// optional .paddle.framework.proto.OpVersionMap op_version_map = 5;
inline bool ProgramDesc::_internal_has_op_version_map() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.op_version_map_ != nullptr);
  return value;
}
inline bool ProgramDesc::has_op_version_map() const {
  return _internal_has_op_version_map();
}
inline void ProgramDesc::clear_op_version_map() {
  if (_impl_.op_version_map_ != nullptr) _impl_.op_version_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::paddle::framework::proto::OpVersionMap& ProgramDesc::_internal_op_version_map() const {
  const ::paddle::framework::proto::OpVersionMap* p = _impl_.op_version_map_;
  return p != nullptr ? *p : reinterpret_cast<const ::paddle::framework::proto::OpVersionMap&>(
      ::paddle::framework::proto::_OpVersionMap_default_instance_);
}
inline const ::paddle::framework::proto::OpVersionMap& ProgramDesc::op_version_map() const {
  // @@protoc_insertion_point(field_get:paddle.framework.proto.ProgramDesc.op_version_map)
  return _internal_op_version_map();
}
inline void ProgramDesc::unsafe_arena_set_allocated_op_version_map(
    ::paddle::framework::proto::OpVersionMap* op_version_map) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.op_version_map_);
  }
  _impl_.op_version_map_ = op_version_map;
  if (op_version_map) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:paddle.framework.proto.ProgramDesc.op_version_map)
}
inline ::paddle::framework::proto::OpVersionMap* ProgramDesc::release_op_version_map() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::paddle::framework::proto::OpVersionMap* temp = _impl_.op_version_map_;
  _impl_.op_version_map_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::paddle::framework::proto::OpVersionMap* ProgramDesc::unsafe_arena_release_op_version_map() {
  // @@protoc_insertion_point(field_release:paddle.framework.proto.ProgramDesc.op_version_map)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::paddle::framework::proto::OpVersionMap* temp = _impl_.op_version_map_;
  _impl_.op_version_map_ = nullptr;
  return temp;
}
inline ::paddle::framework::proto::OpVersionMap* ProgramDesc::_internal_mutable_op_version_map() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.op_version_map_ == nullptr) {
    auto* p = CreateMaybeMessage<::paddle::framework::proto::OpVersionMap>(GetArenaForAllocation());
    _impl_.op_version_map_ = p;
  }
  return _impl_.op_version_map_;
}
inline ::paddle::framework::proto::OpVersionMap* ProgramDesc::mutable_op_version_map() {
  ::paddle::framework::proto::OpVersionMap* _msg = _internal_mutable_op_version_map();
  // @@protoc_insertion_point(field_mutable:paddle.framework.proto.ProgramDesc.op_version_map)
  return _msg;
}
inline void ProgramDesc::set_allocated_op_version_map(::paddle::framework::proto::OpVersionMap* op_version_map) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.op_version_map_;
  }
  if (op_version_map) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(op_version_map);
    if (message_arena != submessage_arena) {
      op_version_map = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, op_version_map, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.op_version_map_ = op_version_map;
  // @@protoc_insertion_point(field_set_allocated:paddle.framework.proto.ProgramDesc.op_version_map)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace framework
}  // namespace paddle

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::paddle::framework::proto::Scalar_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::paddle::framework::proto::Scalar_Type>() {
  return ::paddle::framework::proto::Scalar_Type_descriptor();
}
template <> struct is_proto_enum< ::paddle::framework::proto::VarType_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::paddle::framework::proto::VarType_Type>() {
  return ::paddle::framework::proto::VarType_Type_descriptor();
}
template <> struct is_proto_enum< ::paddle::framework::proto::AttrType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::paddle::framework::proto::AttrType>() {
  return ::paddle::framework::proto::AttrType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_paddle_2fphi_2fcore_2fframework_2fframework_2eproto
